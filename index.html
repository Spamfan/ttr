<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TTR v11</title>
    <style>
        /* CORE STYLES */
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            touch-action: none;
            font-family: 'Verdana', 'Trebuchet MS', sans-serif;
            color: white;
            user-select: none;
            -webkit-user-select: none;
        }

        canvas {
            display: block;
        }

        /* UI OVERLAY - Hidden initially for v11 fix */
        #ui-layer {
            display: none; 
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .hud-text {
            position: absolute;
            text-shadow: 1px 1px 2px black;
            font-weight: bold;
            pointer-events: auto;
        }

        #version-display {
            top: 10px;
            left: 10px;
            font-size: 12px;
            opacity: 0.7;
        }
        
        #fps-counter {
            top: 60px;
            right: 10px;
            text-align: right;
            font-size: 11px;
            color: #0f0;
            opacity: 0.8;
        }

        #hud-stats {
            top: 10px;
            right: 50px;
            text-align: right;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        .heart-row { color: #ff3333; font-size: 20px; letter-spacing: 2px; }
        .cash-row { color: #4CAF50; font-size: 18px; margin-top: 2px; }

        #pause-btn {
            top: 10px;
            right: 10px;
            cursor: pointer;
            font-size: 24px;
            line-height: 24px;
            width: 30px;
            height: 30px;
            text-align: center;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            border: 1px solid #fff;
        }

        /* SCREENS */
        .fullscreen-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
            pointer-events: auto;
        }

        h1 { margin: 0 0 20px 0; color: white; text-transform: uppercase; letter-spacing: 3px; }
        
        .big-btn {
            padding: 20px 40px;
            font-size: 24px;
            background: #00dd00;
            color: #000;
            border: 2px solid #fff;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 0 15px #00dd00;
            touch-action: manipulation;
        }

        /* PAUSE MENU */
        #pause-modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #333;
            border: 2px solid #fff;
            padding: 20px;
            text-align: center;
            min-width: 250px;
            box-shadow: 0 0 15px #000;
            z-index: 20;
            pointer-events: auto;
        }

        #pause-overlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 10;
            pointer-events: auto; 
        }

        .modal-btn {
            display: block;
            width: 100%;
            margin: 10px 0;
            padding: 12px;
            background: #555;
            color: #fff;
            border: 1px solid #aaa;
            cursor: pointer;
            font-family: inherit;
            font-size: 14px;
            touch-action: manipulation;
        }

        .modal-btn.active {
            background: #00dd00;
            color: #000;
            font-weight: bold;
        }
        
        #autofire-desc { font-size: 11px; color: #aaa; margin-bottom: 10px; font-style: italic; }
        #btn-copy-log { display: none; }
        
        #debug-overlay {
            display: none;
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 30%;
            background: rgba(0,0,0,0.5);
            color: #0f0;
            font-family: 'Courier New', monospace;
            overflow-y: scroll;
            font-size: 11px;
            box-sizing: border-box;
            padding: 5px;
            z-index: 5;
            pointer-events: none;
            user-select: none;
        }
        #debug-overlay.interactive { pointer-events: auto; user-select: text; -webkit-user-select: text; background: rgba(0,0,0,0.8); }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <!-- START SCREEN -->
    <div id="start-screen" class="fullscreen-modal">
        <h1>Tank Tycoon</h1>
        <button id="btn-start" class="big-btn">TAP TO START</button>
        <div style="color:#666; margin-top:20px; font-size:12px;">v11</div>
    </div>

    <!-- GAME OVER SCREEN -->
    <div id="game-over-screen" class="fullscreen-modal" style="display:none;">
        <h1 style="color: #ff3333;">TANK DESTROYED</h1>
        <button id="btn-respawn" class="big-btn" style="background: #ff3333; box-shadow: 0 0 15px #ff0000;">RESPAWN</button>
    </div>

    <div id="ui-layer">
        <div id="version-display" class="hud-text">v11</div>
        <div id="hud-stats" class="hud-text">
            <div id="hud-hearts" class="heart-row">❤❤❤</div>
            <div id="hud-cash" class="cash-row">$0</div>
        </div>
        <div id="fps-counter" class="hud-text">FPS: --</div>
        <div id="pause-btn" class="hud-text">&#10074;&#10074;</div>

        <div id="pause-overlay"></div>

        <div id="pause-modal">
            <h3>PAUSED</h3>
            <button id="btn-toggle-fps" class="modal-btn active">Show FPS: ON</button>
            <button id="btn-auto-fire" class="modal-btn active">Auto-Fire: ANY</button>
            <div id="autofire-desc">Fires when right stick is touched.</div>
            <button id="btn-toggle-debug" class="modal-btn">Show Live Debug: OFF</button>
            <button id="btn-copy-log" class="modal-btn">Copy Log</button>
            <button id="btn-close-pause" class="modal-btn" style="background: #800;">RESUME</button>
        </div>
        
        <div id="debug-overlay"></div>
    </div>

    <script>
        /** 
         * TTR ENGINE v11 - HOTFIX
         * Fixes: Fatal Crash in Spawn Logic (OOB), UI Layering, Pause Menu Logic
         */

        const VERSION = "v11";

        // --- CONFIG ---
        const CONFIG = {
            tileSize: 64,
            worldTiles: 50, // 3200x3200
            get worldSize() { return this.tileSize * this.worldTiles; },
            playerSpeed: 250, 
            waterSpeedMult: 0.5, 
            fireRate: 1.0, 
            bulletSpeed: 700, 
            bulletLife: 1.5,
            grassBaseColor: '#2d4c1e',
            waterBaseColor: '#4FC3F7',
            gridColor: 'rgba(255, 255, 255, 0.2)',
            joystickDeadzone: 0.2,
            cameraLerp: 0.1
        };

        // --- STATE ---
        const STATE = {
            gameStarted: false,
            gameOver: false,
            lastTime: 0, 
            showFPS: true, 
            showDebug: false,
            autoFireMode: 0,
            isMobile: false, 
            isPaused: false, 
            audioInitialized: false,
            wasInWater: false
        };

        const CAMERA = { x: 0, y: 0 };
        const FPS = { buffer: [], lastUpdate: 0, display: "FPS: --" };
        const DEBUG_LOG = [];

        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            const entry = `[${timestamp}] ${message}`;
            DEBUG_LOG.push(entry);
            const overlay = document.getElementById('debug-overlay');
            if (overlay) {
                const div = document.createElement('div');
                div.textContent = entry;
                overlay.appendChild(div);
                if (!STATE.isPaused) overlay.scrollTop = overlay.scrollHeight;
            }
        }
        
        // --- AUDIO ---
        let audioCtx = null;
        let splashBuffer = null;

        function initAudio() {
            if (STATE.audioInitialized) return;
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AudioContext();
                STATE.audioInitialized = true;
                createSplashSound();
                log("Audio Init Success.");
            } catch (e) { log("Audio Init Failed."); }
        }

        function createSplashSound() {
            if (!audioCtx) return;
            const bufferSize = audioCtx.sampleRate * 0.5;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * (1 - i/bufferSize);
            splashBuffer = buffer;
        }

        function playSound(type) {
            if (!audioCtx || audioCtx.state !== 'running') return;
            const gainNode = audioCtx.createGain();
            gainNode.connect(audioCtx.destination);

            if (type === 'shoot') {
                const osc = audioCtx.createOscillator();
                osc.type = 'square';
                osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.05, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.connect(gainNode);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'splash' && splashBuffer) {
                const source = audioCtx.createBufferSource();
                source.buffer = splashBuffer;
                const filter = audioCtx.createBiquadFilter();
                filter.type = "lowpass"; filter.frequency.value = 1000;
                source.connect(filter); filter.connect(gainNode);
                gainNode.gain.value = 0.2;
                source.start();
            } else if (type === 'pickup') {
                const osc = audioCtx.createOscillator();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(1200, audioCtx.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
                osc.connect(gainNode);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            }
        }

        // --- INPUT ---
        const INPUT = {
            keys: {}, mouse: { x: 0, y: 0, down: false }, moveVector: { x: 0, y: 0 },
            aimAngle: 0, isFiring: false,
            touches: {
                leftId: null, leftStart: { x: 0, y: 0 }, leftCurr: { x: 0, y: 0 },
                rightId: null, rightStart: { x: 0, y: 0 }, rightCurr: { x: 0, y: 0 }
            }
        };

        const PLAYER = { 
            x: 1600, y: 1600, radius: 20, 
            color: '#37474F', turretColor: '#546E7A', barrelColor: '#263238', treadColor: '#212121', 
            cooldown: 0, bodyAngle: 0, turretAngle: 0,
            hp: 3, maxHp: 3, cash: 0
        };
        
        let BULLETS = [];
        let PARTICLES = [];
        let ENEMIES = [];
        let LOOT = [];
        let WORLD_MAP = []; 

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        let worldCanvas = null;

        function init() {
            log(`Initializing TTR ${VERSION}`);
            generateTerrain();
            createWorldBackground();
            resize();
            window.addEventListener('resize', resize);
            setupInputs();
            setupUI();

            window.addEventListener('blur', () => {
                if (STATE.gameStarted && !STATE.isPaused && !STATE.gameOver) {
                    togglePause(true);
                    resetInputs();
                }
            });

            requestAnimationFrame(gameLoop);
        }

        function resetInputs() {
            INPUT.keys = {}; INPUT.mouse.down = false;
            INPUT.touches.leftId = null; INPUT.touches.rightId = null;
            INPUT.moveVector = {x:0, y:0}; INPUT.isFiring = false;
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (!STATE.gameStarted) {
                CAMERA.x = PLAYER.x - canvas.width/2;
                CAMERA.y = PLAYER.y - canvas.height/2;
            }
        }

        function spawnEnemies() {
            ENEMIES = [];
            for(let i=0; i<8; i++) {
                let safe = false;
                let ex, ey;
                let attempts = 0;
                while(!safe && attempts < 100) {
                    attempts++;
                    ex = Math.random() * CONFIG.worldSize;
                    ey = Math.random() * CONFIG.worldSize;
                    // SAFEGUARD: Clamp logic to prevent crash
                    const gx = Math.max(0, Math.min(Math.floor(ex/CONFIG.tileSize), CONFIG.worldTiles - 1));
                    const gy = Math.max(0, Math.min(Math.floor(ey/CONFIG.tileSize), CONFIG.worldTiles - 1));
                    
                    const dist = Math.hypot(ex-PLAYER.x, ey-PLAYER.y);
                    if (WORLD_MAP[gx][gy] === 0 && dist > 600) safe = true;
                }
                if (safe) {
                    ENEMIES.push({
                        x: ex, y: ey, 
                        angle: Math.random() * Math.PI * 2,
                        cooldown: Math.random() * 2,
                        hp: 3, maxHp: 3, radius: 20
                    });
                }
            }
            log("Enemies Spawned: " + ENEMIES.length);
        }

        function generateTerrain() {
            WORLD_MAP = new Array(CONFIG.worldTiles).fill(0).map(() => new Array(CONFIG.worldTiles).fill(0));
            let seeds = 7; 
            for (let i=0; i<seeds; i++) {
                let x = Math.floor(Math.random() * CONFIG.worldTiles);
                let y = Math.floor(Math.random() * CONFIG.worldTiles);
                // Safety
                x = Math.max(0, Math.min(x, CONFIG.worldTiles - 1));
                y = Math.max(0, Math.min(y, CONFIG.worldTiles - 1));
                
                WORLD_MAP[x][y] = 1;
                let size = 3 + Math.floor(Math.random() * 8);
                for (let j=0; j<size; j++) {
                    x += Math.floor(Math.random() * 3) - 1;
                    y += Math.floor(Math.random() * 3) - 1;
                    if (x >= 0 && x < CONFIG.worldTiles && y >= 0 && y < CONFIG.worldTiles) {
                        WORLD_MAP[x][y] = 1;
                        if (x+1 < CONFIG.worldTiles) WORLD_MAP[x+1][y] = 1;
                        if (y+1 < CONFIG.worldTiles) WORLD_MAP[x][y+1] = 1;
                    }
                }
            }
        }

        function createWorldBackground() {
            worldCanvas = document.createElement('canvas');
            worldCanvas.width = CONFIG.worldSize;
            worldCanvas.height = CONFIG.worldSize;
            const wCtx = worldCanvas.getContext('2d');

            // Grass
            const pSize = 256;
            const pCan = document.createElement('canvas');
            pCan.width = pSize; pCan.height = pSize;
            const pCtx = pCan.getContext('2d');
            pCtx.fillStyle = CONFIG.grassBaseColor;
            pCtx.fillRect(0,0,pSize,pSize);
            for(let i=0; i<800; i++) {
                const x = Math.random() * pSize;
                const y = Math.random() * pSize;
                const len = 2 + Math.random() * 4;
                const shade = 5 + Math.random() * 15;
                pCtx.strokeStyle = `rgba(0, ${shade}, 0, 0.3)`;
                pCtx.beginPath(); pCtx.moveTo(x,y); pCtx.lineTo(x, y-len); pCtx.stroke();
            }
            wCtx.fillStyle = wCtx.createPattern(pCan, 'repeat');
            wCtx.fillRect(0, 0, CONFIG.worldSize, CONFIG.worldSize);

            // Water
            wCtx.lineCap = 'round';
            wCtx.lineJoin = 'round';
            wCtx.lineWidth = 80; 
            wCtx.strokeStyle = CONFIG.waterBaseColor;
            
            wCtx.beginPath();
            for (let x = 0; x < CONFIG.worldTiles; x++) {
                for (let y = 0; y < CONFIG.worldTiles; y++) {
                    if (WORLD_MAP[x][y] === 1) {
                        const cx = (x * CONFIG.tileSize) + (CONFIG.tileSize/2);
                        const cy = (y * CONFIG.tileSize) + (CONFIG.tileSize/2);
                        wCtx.moveTo(cx, cy); wCtx.lineTo(cx, cy);
                        if (x+1 < CONFIG.worldTiles && WORLD_MAP[x+1][y] === 1) wCtx.lineTo(cx + CONFIG.tileSize, cy);
                        wCtx.moveTo(cx, cy);
                        if (y+1 < CONFIG.worldTiles && WORLD_MAP[x][y+1] === 1) wCtx.lineTo(cx, cy + CONFIG.tileSize);
                    }
                }
            }
            wCtx.stroke();

            // Grid
            wCtx.strokeStyle = CONFIG.gridColor;
            wCtx.lineWidth = 1;
            wCtx.lineCap = 'butt'; 
            wCtx.beginPath();
            for (let x = 0; x <= CONFIG.worldSize; x += CONFIG.tileSize) {
                wCtx.moveTo(x, 0); wCtx.lineTo(x, CONFIG.worldSize);
            }
            for (let y = 0; y <= CONFIG.worldSize; y += CONFIG.tileSize) {
                wCtx.moveTo(0, y); wCtx.lineTo(CONFIG.worldSize, y);
            }
            wCtx.stroke();
        }

        // --- INPUT & UPDATE ---
        function setupInputs() {
            window.addEventListener('keydown', e => { INPUT.keys[e.key.toLowerCase()] = true; STATE.isMobile = false; });
            window.addEventListener('keyup', e => { INPUT.keys[e.key.toLowerCase()] = false; });
            window.addEventListener('mousemove', e => { INPUT.mouse.x = e.clientX; INPUT.mouse.y = e.clientY; STATE.isMobile = false; });
            window.addEventListener('mousedown', () => { INPUT.mouse.down = true; STATE.isMobile = false; });
            window.addEventListener('mouseup', () => { INPUT.mouse.down = false; });
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
        }
        function handleTouchStart(e) {
            e.preventDefault();
            STATE.isMobile = true;
            for (let t of e.changedTouches) {
                const isLeft = t.clientX < canvas.width / 2;
                if (isLeft && INPUT.touches.leftId === null) {
                    INPUT.touches.leftId = t.identifier;
                    INPUT.touches.leftStart = { x: t.clientX, y: t.clientY };
                    INPUT.touches.leftCurr = { x: t.clientX, y: t.clientY };
                } else if (!isLeft && INPUT.touches.rightId === null) {
                    INPUT.touches.rightId = t.identifier;
                    INPUT.touches.rightStart = { x: t.clientX, y: t.clientY };
                    INPUT.touches.rightCurr = { x: t.clientX, y: t.clientY };
                }
            }
        }
        function handleTouchMove(e) {
            e.preventDefault();
            for (let t of e.changedTouches) {
                if (t.identifier === INPUT.touches.leftId) INPUT.touches.leftCurr = { x: t.clientX, y: t.clientY };
                else if (t.identifier === INPUT.touches.rightId) INPUT.touches.rightCurr = { x: t.clientX, y: t.clientY };
            }
        }
        function handleTouchEnd(e) {
            e.preventDefault();
            for (let t of e.changedTouches) {
                if (t.identifier === INPUT.touches.leftId) {
                    INPUT.touches.leftId = null;
                    INPUT.moveVector = { x: 0, y: 0 };
                } else if (t.identifier === INPUT.touches.rightId) {
                    INPUT.touches.rightId = null;
                    INPUT.isFiring = false;
                }
            }
        }

        function update(dt) {
            if (!STATE.gameStarted || STATE.isPaused || STATE.gameOver) return;
            if (dt > 0.1) dt = 0.1;

            // Player Inputs
            if (STATE.isMobile) {
                if (INPUT.touches.leftId !== null) {
                    const dx = INPUT.touches.leftCurr.x - INPUT.touches.leftStart.x;
                    const dy = INPUT.touches.leftCurr.y - INPUT.touches.leftStart.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist > 0) {
                        const power = Math.min(dist, 50) / 50;
                        INPUT.moveVector = { x: (dx/dist)*power, y: (dy/dist)*power };
                    }
                }
                if (INPUT.touches.rightId !== null) {
                    const dx = INPUT.touches.rightCurr.x - INPUT.touches.rightStart.x;
                    const dy = INPUT.touches.rightCurr.y - INPUT.touches.rightStart.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if ((dist / 50) > CONFIG.joystickDeadzone) INPUT.aimAngle = Math.atan2(dy, dx);
                    if (STATE.autoFireMode === 0) INPUT.isFiring = true;
                    else INPUT.isFiring = (dist / 50) > CONFIG.joystickDeadzone;
                }
            } else {
                INPUT.moveVector = { x: 0, y: 0 };
                if (INPUT.keys['w'] || INPUT.keys['arrowup']) INPUT.moveVector.y = -1;
                if (INPUT.keys['s'] || INPUT.keys['arrowdown']) INPUT.moveVector.y = 1;
                if (INPUT.keys['a'] || INPUT.keys['arrowleft']) INPUT.moveVector.x = -1;
                if (INPUT.keys['d'] || INPUT.keys['arrowright']) INPUT.moveVector.x = 1;
                if (INPUT.moveVector.x !== 0 || INPUT.moveVector.y !== 0) {
                    const len = Math.sqrt(INPUT.moveVector.x**2 + INPUT.moveVector.y**2);
                    INPUT.moveVector.x /= len; INPUT.moveVector.y /= len;
                }
                INPUT.aimAngle = Math.atan2((INPUT.mouse.y + CAMERA.y) - PLAYER.y, (INPUT.mouse.x + CAMERA.x) - PLAYER.x);
                INPUT.isFiring = INPUT.mouse.down;
            }

            if (INPUT.moveVector.x !== 0 || INPUT.moveVector.y !== 0) PLAYER.bodyAngle = Math.atan2(INPUT.moveVector.y, INPUT.moveVector.x);
            PLAYER.turretAngle = INPUT.aimAngle;

            // Physics with Safety Clamping
            let currentSpeed = CONFIG.playerSpeed;
            const gx = Math.max(0, Math.min(Math.floor(PLAYER.x / CONFIG.tileSize), CONFIG.worldTiles - 1));
            const gy = Math.max(0, Math.min(Math.floor(PLAYER.y / CONFIG.tileSize), CONFIG.worldTiles - 1));
            const inWater = (WORLD_MAP[gx][gy] === 1);
            
            if (inWater) {
                currentSpeed *= CONFIG.waterSpeedMult;
                if (!STATE.wasInWater) playSound('splash');
                if ((INPUT.moveVector.x !== 0 || INPUT.moveVector.y !== 0) && Math.random() < 0.3) {
                    PARTICLES.push({
                        x: PLAYER.x + (Math.random()-0.5)*20,
                        y: PLAYER.y + (Math.random()-0.5)*20,
                        size: 3 + Math.random()*4, life: 0.5, color: '#81D4FA'
                    });
                }
            }
            STATE.wasInWater = inWater;

            PLAYER.x += INPUT.moveVector.x * currentSpeed * dt;
            PLAYER.y += INPUT.moveVector.y * currentSpeed * dt;
            PLAYER.x = Math.max(PLAYER.radius, Math.min(CONFIG.worldSize - PLAYER.radius, PLAYER.x));
            PLAYER.y = Math.max(PLAYER.radius, Math.min(CONFIG.worldSize - PLAYER.radius, PLAYER.y));
            
            const targetCamX = PLAYER.x - canvas.width / 2;
            const targetCamY = PLAYER.y - canvas.height / 2;
            CAMERA.x += (targetCamX - CAMERA.x) * CONFIG.cameraLerp;
            CAMERA.y += (targetCamY - CAMERA.y) * CONFIG.cameraLerp;

            if (PLAYER.cooldown > 0) PLAYER.cooldown -= dt;
            if (INPUT.isFiring && PLAYER.cooldown <= 0) {
                fireWeapon(PLAYER, 'player');
                PLAYER.cooldown = CONFIG.fireRate;
            }

            for (let i = ENEMIES.length - 1; i >= 0; i--) {
                let e = ENEMIES[i];
                let dist = Math.hypot(PLAYER.x - e.x, PLAYER.y - e.y);
                if (dist < 600) {
                    e.angle = Math.atan2(PLAYER.y - e.y, PLAYER.x - e.x);
                    if (e.cooldown > 0) e.cooldown -= dt;
                    if (e.cooldown <= 0) {
                        fireWeapon(e, 'enemy');
                        e.cooldown = 1.5 + Math.random();
                    }
                }
            }

            for (let i = BULLETS.length - 1; i >= 0; i--) {
                const b = BULLETS[i];
                b.x += b.vx * dt; b.y += b.vy * dt; b.life -= dt;
                let hit = false;
                if (b.owner === 'player') {
                    for (let j = ENEMIES.length - 1; j >= 0; j--) {
                        let e = ENEMIES[j];
                        if (Math.hypot(b.x - e.x, b.y - e.y) < e.radius + 5) {
                            e.hp--; hit = true;
                            if (e.hp <= 0) { dropLoot(e.x, e.y); ENEMIES.splice(j, 1); }
                            break;
                        }
                    }
                } else if (b.owner === 'enemy') {
                    if (Math.hypot(b.x - PLAYER.x, b.y - PLAYER.y) < PLAYER.radius + 5) {
                        PLAYER.hp--; updateHUD(); hit = true;
                        if (PLAYER.hp <= 0) doGameOver();
                    }
                }
                if (b.life <= 0 || hit) BULLETS.splice(i, 1);
            }

            for (let i = LOOT.length - 1; i >= 0; i--) {
                let l = LOOT[i];
                if (Math.hypot(PLAYER.x - l.x, PLAYER.y - l.y) < PLAYER.radius + 15) {
                    playSound('pickup');
                    if (l.type === 0 && PLAYER.hp < PLAYER.maxHp) PLAYER.hp++;
                    else if (l.type === 1) PLAYER.cash += 1;
                    else if (l.type === 2) PLAYER.cash += 5;
                    updateHUD();
                    LOOT.splice(i, 1);
                }
            }

            for (let i = PARTICLES.length - 1; i >= 0; i--) {
                const p = PARTICLES[i];
                p.life -= dt;
                if (p.life <= 0) PARTICLES.splice(i, 1);
            }
        }

        function fireWeapon(source, type) {
            if (type === 'player') playSound('shoot');
            const angle = (type === 'player') ? source.turretAngle : source.angle;
            const bX = source.x + Math.cos(angle) * 35;
            const bY = source.y + Math.sin(angle) * 35;
            BULLETS.push({
                x: bX, y: bY,
                vx: Math.cos(angle) * CONFIG.bulletSpeed,
                vy: Math.sin(angle) * CONFIG.bulletSpeed,
                life: CONFIG.bulletLife,
                owner: type
            });
        }

        function dropLoot(x, y) {
            const rand = Math.random();
            let type = 0;
            if (rand < 0.33) type = 0; 
            else if (rand < 0.66) type = 2; 
            else type = 1; 
            LOOT.push({ x, y, type });
        }

        function updateHUD() {
            let hearts = "";
            for(let i=0; i<PLAYER.hp; i++) hearts += "❤";
            document.getElementById('hud-hearts').innerText = hearts;
            document.getElementById('hud-cash').innerText = "$" + PLAYER.cash;
        }

        function doGameOver() {
            STATE.gameOver = true;
            document.getElementById('game-over-screen').style.display = 'flex';
        }

        function respawn() {
            PLAYER.hp = 3; PLAYER.x = 1600; PLAYER.y = 1600;
            STATE.gameOver = false; BULLETS = [];
            updateHUD();
            document.getElementById('game-over-screen').style.display = 'none';
            resetInputs();
            CAMERA.x = PLAYER.x - canvas.width/2;
            CAMERA.y = PLAYER.y - canvas.height/2;
        }

        function draw() {
            ctx.fillStyle = '#000000'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (!worldCanvas) return;

            ctx.save();
            ctx.translate(-CAMERA.x, -CAMERA.y);

            ctx.drawImage(worldCanvas, 0, 0);
            ctx.strokeStyle = '#555'; ctx.lineWidth = 5; ctx.strokeRect(0, 0, CONFIG.worldSize, CONFIG.worldSize);

            for (let l of LOOT) {
                ctx.save(); ctx.translate(l.x, l.y);
                if (l.type === 0) { ctx.fillStyle = '#ff3333'; ctx.font = "20px Arial"; ctx.fillText("❤", -10, 5); }
                else if (l.type === 1) { ctx.fillStyle = '#4CAF50'; ctx.fillRect(-8, -12, 16, 24); ctx.fillStyle='white'; ctx.fillText("$1", -10, 5); }
                else if (l.type === 2) { ctx.fillStyle = '#2E7D32'; ctx.fillRect(-10, -14, 20, 28); ctx.fillStyle='white'; ctx.fillText("$5", -10, 5); }
                ctx.restore();
            }

            for (let p of PARTICLES) {
                ctx.fillStyle = p.color; ctx.globalAlpha = p.life * 2;
                ctx.fillRect(p.x, p.y, p.size, p.size); ctx.globalAlpha = 1.0;
            }

            for (let e of ENEMIES) {
                ctx.save(); ctx.translate(e.x, e.y);
                ctx.fillStyle = 'red'; ctx.fillRect(-15, -35, 30, 4);
                ctx.fillStyle = '#0f0'; ctx.fillRect(-15, -35, 30 * (e.hp/e.maxHp), 4);
                ctx.rotate(e.angle);
                ctx.fillStyle = '#C62828'; ctx.fillRect(-20, -18, 40, 36);
                ctx.fillStyle = '#8E0000'; ctx.fillRect(-20, -22, 40, 4); ctx.fillRect(-20, 18, 40, 4);
                ctx.fillStyle = '#B71C1C'; ctx.fillRect(0, -4, 35, 8);
                ctx.beginPath(); ctx.arc(0, 0, 11, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            }

            ctx.lineWidth = 3; ctx.beginPath();
            for (let b of BULLETS) {
                ctx.strokeStyle = (b.owner === 'player') ? '#ffff00' : '#ff0000';
                const tX = b.x - (b.vx / CONFIG.bulletSpeed) * 15;
                const tY = b.y - (b.vy / CONFIG.bulletSpeed) * 15;
                ctx.moveTo(tX, tY); ctx.lineTo(b.x, b.y);
            }
            ctx.stroke();

            ctx.save(); ctx.translate(PLAYER.x, PLAYER.y);
            ctx.save(); ctx.rotate(PLAYER.bodyAngle);
            ctx.fillStyle = PLAYER.color; ctx.fillRect(-20, -18, 40, 36);
            ctx.fillStyle = PLAYER.treadColor; ctx.fillRect(-20, -22, 40, 4); ctx.fillRect(-20, 18, 40, 4);
            ctx.restore();
            ctx.save(); ctx.rotate(PLAYER.turretAngle);
            ctx.fillStyle = PLAYER.barrelColor; ctx.fillRect(0, -4, 35, 8);
            ctx.fillStyle = PLAYER.turretColor; ctx.beginPath(); ctx.arc(0, 0, 11, 0, Math.PI * 2); ctx.fill();
            ctx.strokeStyle = PLAYER.barrelColor; ctx.lineWidth = 1.5; ctx.stroke();
            ctx.restore(); ctx.restore();

            ctx.restore();

            if (STATE.gameStarted && !STATE.isPaused && !STATE.gameOver) {
                if (INPUT.touches.leftId !== null) drawJoystick(INPUT.touches.leftStart, INPUT.touches.leftCurr);
                if (INPUT.touches.rightId !== null) drawJoystick(INPUT.touches.rightStart, INPUT.touches.rightCurr);
            }
        }

        function drawJoystick(start, curr) {
            ctx.beginPath(); ctx.arc(start.x, start.y, 50, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)'; ctx.lineWidth = 2; ctx.stroke();
            ctx.beginPath(); ctx.arc(curr.x, curr.y, 20, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'; ctx.fill();
        }

        function setupUI() {
            const bindBtn = (id, callback) => {
                const el = document.getElementById(id);
                const handler = (e) => {
                    e.preventDefault(); e.stopPropagation();
                    callback(el);
                    return false;
                };
                el.addEventListener('touchend', handler, {passive: false});
                el.addEventListener('click', handler);
            };

            bindBtn('btn-start', () => {
                initAudio();
                STATE.gameStarted = true;
                spawnEnemies();
                document.getElementById('start-screen').style.display = 'none';
                document.getElementById('ui-layer').style.display = 'block'; // SHOW UI NOW
                CAMERA.x = PLAYER.x - canvas.width/2;
                CAMERA.y = PLAYER.y - canvas.height/2;
            });

            bindBtn('btn-respawn', () => respawn());

            const togglePause = (pause) => {
                STATE.isPaused = pause;
                document.getElementById('pause-modal').style.display = pause ? 'block' : 'none';
                document.getElementById('pause-overlay').style.display = pause ? 'block' : 'none';
                if (!pause) STATE.lastTime = performance.now();
            };

            bindBtn('pause-btn', () => togglePause(true));
            bindBtn('btn-close-pause', () => togglePause(false));
            
            const overlay = document.getElementById('pause-overlay');
            const closeIfBg = (e) => {
                if (e.target === overlay) {
                    e.preventDefault(); e.stopPropagation();
                    togglePause(false);
                }
            };
            overlay.addEventListener('touchend', closeIfBg);
            overlay.addEventListener('click', closeIfBg);

            bindBtn('btn-toggle-fps', (el) => {
                STATE.showFPS = !STATE.showFPS;
                document.getElementById('fps-counter').style.display = STATE.showFPS ? 'block' : 'none';
                el.innerText = `Show FPS: ${STATE.showFPS ? 'ON' : 'OFF'}`;
                el.classList.toggle('active');
            });

            bindBtn('btn-auto-fire', (el) => {
                STATE.autoFireMode = (STATE.autoFireMode + 1) % 2;
                if (STATE.autoFireMode === 0) {
                    el.innerText = `Auto-Fire: ANY`;
                    document.getElementById('autofire-desc').innerText = "Fires when right stick is touched.";
                } else {
                    el.innerText = `Auto-Fire: AIMING`;
                    document.getElementById('autofire-desc').innerText = "Fires only when aiming.";
                }
            });

            bindBtn('btn-toggle-debug', (el) => {
                STATE.showDebug = !STATE.showDebug;
                document.getElementById('debug-overlay').style.display = STATE.showDebug ? 'block' : 'none';
                document.getElementById('btn-copy-log').style.display = STATE.showDebug ? 'block' : 'none';
                el.innerText = `Show Live Debug: ${STATE.showDebug ? 'ON' : 'OFF'}`;
                el.classList.toggle('active');
            });

            bindBtn('btn-copy-log', () => {
                navigator.clipboard.writeText(DEBUG_LOG.join('\n')).then(() => log("Copied."));
            });
        }

        function gameLoop(timestamp) {
            if (!STATE.lastTime) STATE.lastTime = timestamp;
            const dt = (timestamp - STATE.lastTime) / 1000;
            STATE.lastTime = timestamp;
            update(dt);
            draw();
            
            if (STATE.showFPS && dt > 0) {
                const currentFPS = 1 / dt;
                FPS.buffer.push(currentFPS);
                if (FPS.buffer.length > 30) FPS.buffer.shift();
                
                if (timestamp - FPS.lastUpdate >= 500) {
                    const sum = FPS.buffer.reduce((a, b) => a + b, 0);
                    const avg = Math.round(sum / FPS.buffer.length);
                    const sorted = [...FPS.buffer].sort((a, b) => a - b);
                    const low1 = Math.round(sorted[0]);
                    FPS.display = `FPS: ${avg} (Low: ${low1})`;
                    FPS.lastUpdate = timestamp;
                    document.getElementById('fps-counter').innerText = FPS.display;
                }
            }
            requestAnimationFrame(gameLoop);
        }

        const togglePause = (pause) => {
            STATE.isPaused = pause;
            document.getElementById('pause-modal').style.display = pause ? 'block' : 'none';
            document.getElementById('pause-overlay').style.display = pause ? 'block' : 'none';
            if (!pause) STATE.lastTime = performance.now();
        };

        init();
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TTR v13</title>
    <style>
        /* CORE STYLES */
        body {
            margin: 0;
            padding: 0;
            background-color: #111;
            overflow: hidden;
            touch-action: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #eee;
            user-select: none;
            -webkit-user-select: none;
        }

        canvas {
            display: block;
        }

        /* UI OVERLAY */
        #ui-layer {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .hud-text {
            text-shadow: 1px 1px 2px #000;
            font-weight: 600;
            pointer-events: auto;
            letter-spacing: 1px;
        }

        /* TOP LEFT INFO */
        #top-left-info {
            position: absolute;
            top: 15px;
            left: 15px;
            display: flex;
            gap: 15px;
            font-size: 12px;
            color: #aaa;
            pointer-events: none;
        }

        /* PLAYER HP BAR */
        #hud-hp-container {
            position: absolute;
            top: 15px;
            right: 60px;
            width: 220px;
            height: 28px;
            background: #000;
            border: 2px solid #444;
            border-radius: 2px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }

        #hud-hp-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #4CAF50, #2E7D32);
            transition: width 0.2s;
        }

        #hud-hp-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            line-height: 28px;
            text-align: center;
            font-size: 14px;
            color: #fff;
            text-shadow: 1px 1px 2px #000;
        }

        #hud-cash {
            position: absolute;
            top: 50px;
            right: 60px;
            font-size: 20px;
            color: #81C784;
            text-align: right;
            font-family: monospace;
        }

        #hud-zone-msg {
            position: absolute;
            top: 20%;
            width: 100%;
            text-align: center;
            font-size: 18px;
            color: #FFD700;
            text-shadow: 0 2px 4px #000;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #pause-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            cursor: pointer;
            font-size: 24px;
            line-height: 28px;
            width: 32px;
            height: 32px;
            text-align: center;
            background: rgba(0,0,0,0.5);
            border: 1px solid #666;
            border-radius: 4px;
            pointer-events: auto;
        }

        /* MANUAL FIRE BUTTON */
        #btn-manual-fire {
            display: none;
            position: absolute;
            bottom: 20%;
            right: 15%;
            width: 90px;
            height: 90px;
            background: radial-gradient(circle, rgba(255, 80, 80, 0.6) 0%, rgba(200, 40, 40, 0.8) 100%);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: auto;
            touch-action: manipulation;
            box-shadow: 0 4px 10px rgba(0,0,0,0.6);
        }
        
        #btn-manual-fire:active { transform: scale(0.95); filter: brightness(1.2); }

        /* SCREENS */
        .fullscreen-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #111;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
            pointer-events: auto;
        }

        h1 { margin: 0 0 20px 0; color: #ccc; text-transform: uppercase; letter-spacing: 4px; font-weight: 300; border-bottom: 1px solid #444; padding-bottom: 10px;}
        
        .big-btn {
            padding: 15px 50px;
            font-size: 20px;
            background: linear-gradient(180deg, #333, #222);
            color: #ddd;
            border: 1px solid #555;
            border-radius: 2px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            touch-action: manipulation;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .big-btn:active { background: #444; transform: translateY(2px); }

        #loading-bar-container {
            width: 60%;
            height: 10px;
            background: #222;
            border: 1px solid #444;
            margin-top: 20px;
            display: none;
        }
        #loading-bar-fill {
            width: 0%;
            height: 100%;
            background: #4CAF50;
            transition: width 0.1s;
        }
        #loading-text { color: #666; font-size: 12px; margin-top: 5px; min-height: 15px;}

        /* PAUSE MENU */
        #pause-modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(30, 30, 30, 0.95);
            border: 1px solid #555;
            padding: 30px;
            text-align: center;
            min-width: 280px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
            z-index: 20;
            pointer-events: auto;
        }

        #pause-overlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10;
            pointer-events: auto; 
        }

        .modal-btn {
            display: block;
            width: 100%;
            margin: 10px 0;
            padding: 12px;
            background: #333;
            color: #ccc;
            border: 1px solid #555;
            cursor: pointer;
            font-family: inherit;
            font-size: 14px;
            touch-action: manipulation;
        }
        .modal-btn.active { background: #2E7D32; color: #fff; border-color: #4CAF50; }
        
        #autofire-desc { font-size: 11px; color: #888; margin-bottom: 15px; font-style: italic; }
        #btn-copy-log { display: none; }
        
        #debug-overlay {
            display: none;
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 30%;
            background: rgba(0,0,0,0.5);
            color: #0f0;
            font-family: monospace;
            overflow-y: scroll;
            font-size: 11px;
            box-sizing: border-box;
            padding: 5px;
            z-index: 5;
            pointer-events: none;
            user-select: none;
        }
        #debug-overlay.interactive { pointer-events: auto; user-select: text; -webkit-user-select: text; background: rgba(0,0,0,0.8); }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <!-- START SCREEN -->
    <div id="start-screen" class="fullscreen-modal">
        <h1>Tank Tycoon</h1>
        <button id="btn-start" class="big-btn">INITIALIZE</button>
        <div id="loading-bar-container">
            <div id="loading-bar-fill"></div>
        </div>
        <div id="loading-text">v13 - Ready</div>
    </div>

    <!-- GAME OVER SCREEN -->
    <div id="game-over-screen" class="fullscreen-modal" style="display:none;">
        <h1 style="color: #ff3333; border-color: #ff3333;">CRITICAL FAILURE</h1>
        <button id="btn-respawn" class="big-btn" style="background: #500; border-color: #f00;">REDEPLOY</button>
    </div>

    <div id="ui-layer">
        <div id="top-left-info">
            <span id="version-display">v13</span>
            <span id="fps-counter">FPS: --</span>
        </div>

        <div id="hud-hp-container">
            <div id="hud-hp-fill"></div>
            <div id="hud-hp-text">3/3</div>
        </div>
        <div id="hud-cash">$0</div>
        <div id="hud-zone-msg"></div>
        
        <div id="pause-btn">&#10074;&#10074;</div>
        <div id="btn-manual-fire"></div>

        <div id="pause-overlay"></div>

        <div id="pause-modal">
            <h3 style="color:#ccc; margin-top:0;">SYSTEM PAUSED</h3>
            <button id="btn-toggle-fps" class="modal-btn active">Show FPS: ON</button>
            <button id="btn-toggle-grid" class="modal-btn">Show Grid: OFF</button>
            <button id="btn-auto-fire" class="modal-btn active">Auto-Fire: ANY</button>
            <div id="autofire-desc">Fires when right stick is touched.</div>
            <button id="btn-toggle-debug" class="modal-btn">Show Live Debug: OFF</button>
            <button id="btn-copy-log" class="modal-btn">Copy Log</button>
            <button id="btn-close-pause" class="modal-btn" style="background: #500; border-color: #800;">RESUME</button>
        </div>
        
        <div id="debug-overlay"></div>
    </div>

    <script>
        /** 
         * TTR ENGINE v13
         * Core: Gridless Perlin Noise Engine, Baked "Tactical" Textures, Base Building
         */

        const VERSION = "v13";

        // --- CONFIG ---
        const CONFIG = {
            worldSize: 3200,
            
            // "Halo Reach Low" Palette
            colors: {
                land: '#4b5320', // Olive Drab
                landNoise: '#3e4418',
                waterDeep: '#1a262f', // Murky Blue/Grey
                waterShallow: '#2b3e4d',
                concrete: '#555555',
                tankBody: '#37474F',
                tankTurret: '#546E7A',
                enemyBody: '#8D6E63', // Brown/Rust
            },

            playerSpeed: 250, 
            waterSpeedMult: 0.5, 
            fireRate: 1.0, 
            bulletSpeed: 700, 
            bulletLife: 1.5,
            
            joystickDeadzone: 0.2,
            cameraDamping: 10
        };

        // --- STATE ---
        const STATE = {
            gameStarted: false,
            gameOver: false,
            lastTime: 0, 
            showFPS: true, 
            showDebug: false,
            showGrid: false,
            autoFireMode: 0,
            isMobile: false, 
            isPaused: false, 
            audioInitialized: false,
            wasInWater: false,
            manualFirePressed: false
        };

        const CAMERA = { x: 0, y: 0 };
        const FPS = { buffer: [], lastUpdate: 0, display: "FPS: --" };
        const DEBUG_LOG = [];

        // --- WORLD DATA (Gridless) ---
        // 0 = Land, 1 = Water, 2 = Concrete
        // We use a Uint8Array for the physics map to save memory (3200x3200 = ~10MB)
        let PHYSICS_MAP = null; 
        
        // Shops (Coordinate Based)
        const SHOPS = [
            { id: 'med', type: 'med', x: 1550, y: 1550, w: 60, h: 60, price: 15, unlocked: false, color: '#444', icon: '+' },
            { id: 'cash', type: 'cash', x: 1650, y: 1550, w: 60, h: 60, price: 10, unlocked: false, color: '#444', icon: '$' }
        ];
        // Timers for shop effects
        let shopTimer = 0;

        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            const entry = `[${timestamp}] ${message}`;
            DEBUG_LOG.push(entry);
            const overlay = document.getElementById('debug-overlay');
            if (overlay) {
                const div = document.createElement('div');
                div.textContent = entry;
                overlay.appendChild(div);
                if (!STATE.isPaused) overlay.scrollTop = overlay.scrollHeight;
            }
        }

        // --- PERLIN NOISE IMPLEMENTATION (Simplified) ---
        const Noise = (function() {
            const p = new Uint8Array(512);
            const permutation = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
            for (let i=0; i < 256 ; i++) p[256+i] = p[i] = permutation[i];

            function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            function lerp(t, a, b) { return a + t * (b - a); }
            function grad(hash, x, y, z) {
                const h = hash & 15;
                const u = h<8 ? x : y, v = h<4 ? y : h==12||h==14 ? x : z;
                return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);
            }

            return {
                perlin2: function(x, y) {
                    const X = Math.floor(x) & 255, Y = Math.floor(y) & 255;
                    x -= Math.floor(x); y -= Math.floor(y);
                    const u = fade(x), v = fade(y);
                    const A = p[X]+Y, AA = p[A], AB = p[A+1], B = p[X+1]+Y, BA = p[B], BB = p[B+1];
                    return lerp(v, lerp(u, grad(p[AA], x, y, 0), grad(p[BA], x-1, y, 0)),
                                   lerp(u, grad(p[AB], x, y-1, 0), grad(p[BB], x-1, y-1, 0)));
                }
            };
        })();

        // --- GAME OBJECTS ---
        const PLAYER = { 
            x: 1600, y: 1600, radius: 20, 
            cooldown: 0, bodyAngle: 0, turretAngle: 0,
            hp: 3, maxHp: 3, cash: 0
        };
        
        let BULLETS = [];
        let PARTICLES = [];
        let ENEMIES = [];
        let LOOT = [];

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        let worldCanvas = null;

        // --- INITIALIZATION ---
        function init() {
            log(`Initializing TTR ${VERSION}`);
            resize();
            window.addEventListener('resize', resize);
            
            // UI Bindings
            const btnStart = document.getElementById('btn-start');
            btnStart.onclick = () => {
                initAudio();
                btnStart.style.display = 'none';
                document.getElementById('loading-bar-container').style.display = 'block';
                document.getElementById('loading-text').innerText = "Generating World...";
                // Start Async Generation
                setTimeout(generateWorld, 100);
            };

            setupInputs();
            setupUI();

            window.addEventListener('blur', () => {
                if (STATE.gameStarted && !STATE.isPaused && !STATE.gameOver) {
                    togglePause(true);
                    resetInputs();
                }
            });
        }

        // --- WORLD GENERATION (The Heavy Lifting) ---
        function generateWorld() {
            const size = CONFIG.worldSize;
            PHYSICS_MAP = new Uint8Array(size * size);
            worldCanvas = document.createElement('canvas');
            worldCanvas.width = size;
            worldCanvas.height = size;
            const wCtx = worldCanvas.getContext('2d');

            // 1. Fill Base (Olive Drab)
            wCtx.fillStyle = CONFIG.colors.land;
            wCtx.fillRect(0, 0, size, size);

            // 2. Generate Noise Map & Physics
            // We process in chunks to keep UI responsive
            const noiseScale = 0.003;
            const chunkSize = 100; // Rows per frame
            let y = 0;

            function processChunk() {
                const imgData = wCtx.getImageData(0, y, size, chunkSize);
                const data = imgData.data;

                for (let row = 0; row < chunkSize; row++) {
                    if (y + row >= size) break;
                    const cy = y + row;
                    for (let cx = 0; cx < size; cx++) {
                        // Base Zone (Concrete)
                        const distToCenter = Math.hypot(cx - 1600, cy - 1600);
                        if (distToCenter < 150) {
                            // Base
                            const idx = (row * size + cx) * 4;
                            const pIdx = cy * size + cx;
                            PHYSICS_MAP[pIdx] = 2; // Concrete
                            // Grey Concrete Texture
                            const n = Math.random() * 20;
                            data[idx] = 80 + n;
                            data[idx+1] = 80 + n;
                            data[idx+2] = 80 + n;
                            data[idx+3] = 255;
                            continue;
                        }

                        // Terrain Noise
                        const n = Noise.perlin2(cx * noiseScale, cy * noiseScale);
                        const idx = (row * size + cx) * 4;
                        const pIdx = cy * size + cx;

                        if (n < -0.1) {
                            // Water
                            PHYSICS_MAP[pIdx] = 1;
                            // Gradient Blue based on depth
                            const depth = Math.abs(n); // 0.1 to 1.0
                            data[idx] = 26 + (depth * 20); // R
                            data[idx+1] = 38 + (depth * 40); // G
                            data[idx+2] = 47 + (depth * 60); // B
                            data[idx+3] = 255;
                        } else {
                            // Land
                            PHYSICS_MAP[pIdx] = 0;
                            // Add Grit/Noise to land
                            const grit = (Math.random() - 0.5) * 20;
                            data[idx] = 75 + grit;
                            data[idx+1] = 83 + grit;
                            data[idx+2] = 32 + grit;
                            data[idx+3] = 255;
                        }
                    }
                }
                
                wCtx.putImageData(imgData, 0, y);
                y += chunkSize;

                // Update Progress
                const pct = Math.min(100, Math.round((y / size) * 100));
                document.getElementById('loading-bar-fill').style.width = pct + "%";

                if (y < size) {
                    requestAnimationFrame(processChunk);
                } else {
                    finalizeWorld();
                }
            }
            processChunk();
        }

        function finalizeWorld() {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('ui-layer').style.display = 'block';
            STATE.gameStarted = true;
            spawnEnemies();
            CAMERA.x = PLAYER.x - canvas.width/2;
            CAMERA.y = PLAYER.y - canvas.height/2;
            requestAnimationFrame(gameLoop);
            log("World Generation Complete.");
        }

        // --- AUDIO ---
        let audioCtx = null;
        let splashBuffer = null;

        function initAudio() {
            if (STATE.audioInitialized) return;
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AudioContext();
                STATE.audioInitialized = true;
                createSplashSound();
            } catch (e) { log("Audio Error"); }
        }

        function createSplashSound() {
            if (!audioCtx) return;
            const bufferSize = audioCtx.sampleRate * 0.5;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * (1 - i/bufferSize);
            splashBuffer = buffer;
        }

        function playSound(type) {
            if (!audioCtx || audioCtx.state !== 'running') return;
            const gain = audioCtx.createGain();
            gain.connect(audioCtx.destination);

            if (type === 'shoot') {
                const osc = audioCtx.createOscillator();
                osc.type = 'square';
                osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.connect(gain); osc.start(); osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'enemy_shoot') {
                const osc = audioCtx.createOscillator();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(200, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.15);
                gain.gain.setValueAtTime(0.06, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                osc.connect(gain); osc.start(); osc.stop(audioCtx.currentTime + 0.15);
            } else if (type === 'splash' && splashBuffer) {
                const src = audioCtx.createBufferSource();
                src.buffer = splashBuffer;
                const filter = audioCtx.createBiquadFilter();
                filter.type = "lowpass"; filter.frequency.value = 1000;
                src.connect(filter); filter.connect(gain);
                gain.gain.value = 0.2; src.start();
            } else if (type === 'pickup') {
                const osc = audioCtx.createOscillator();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(1200, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
                osc.connect(gain); osc.start(); osc.stop(audioCtx.currentTime + 0.1);
            }
        }

        // --- INPUTS ---
        const INPUT = { keys: {}, mouse: { x: 0, y: 0, down: false }, moveVector: { x: 0, y: 0 }, aimAngle: 0, isFiring: false, touches: { leftId: null, leftStart: {x:0,y:0}, leftCurr: {x:0,y:0}, rightId: null, rightStart: {x:0,y:0}, rightCurr: {x:0,y:0} } };

        function setupInputs() {
            window.addEventListener('keydown', e => { INPUT.keys[e.key.toLowerCase()] = true; STATE.isMobile = false; });
            window.addEventListener('keyup', e => { INPUT.keys[e.key.toLowerCase()] = false; });
            window.addEventListener('mousemove', e => { INPUT.mouse.x = e.clientX; INPUT.mouse.y = e.clientY; STATE.isMobile = false; });
            window.addEventListener('mousedown', () => { INPUT.mouse.down = true; STATE.isMobile = false; });
            window.addEventListener('mouseup', () => { INPUT.mouse.down = false; });
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
        }
        function handleTouchStart(e) {
            e.preventDefault(); STATE.isMobile = true;
            for (let t of e.changedTouches) {
                const isLeft = t.clientX < canvas.width / 2;
                if (isLeft && INPUT.touches.leftId === null) { INPUT.touches.leftId = t.identifier; INPUT.touches.leftStart = {x:t.clientX,y:t.clientY}; INPUT.touches.leftCurr = {x:t.clientX,y:t.clientY}; }
                else if (!isLeft && INPUT.touches.rightId === null) { INPUT.touches.rightId = t.identifier; INPUT.touches.rightStart = {x:t.clientX,y:t.clientY}; INPUT.touches.rightCurr = {x:t.clientX,y:t.clientY}; }
            }
            updateManualFireButton();
        }
        function handleTouchMove(e) {
            e.preventDefault();
            for (let t of e.changedTouches) {
                if (t.identifier === INPUT.touches.leftId) INPUT.touches.leftCurr = {x:t.clientX,y:t.clientY};
                else if (t.identifier === INPUT.touches.rightId) INPUT.touches.rightCurr = {x:t.clientX,y:t.clientY};
            }
        }
        function handleTouchEnd(e) {
            e.preventDefault();
            for (let t of e.changedTouches) {
                if (t.identifier === INPUT.touches.leftId) { INPUT.touches.leftId = null; INPUT.moveVector = {x:0,y:0}; }
                else if (t.identifier === INPUT.touches.rightId) INPUT.touches.rightId = null;
            }
        }
        function updateManualFireButton() {
            const btn = document.getElementById('btn-manual-fire');
            btn.style.display = (STATE.isMobile && STATE.autoFireMode === 2) ? 'block' : 'none';
        }
        function resetInputs() {
            INPUT.keys = {}; INPUT.mouse.down = false; INPUT.touches.leftId = null; INPUT.touches.rightId = null; INPUT.moveVector = {x:0,y:0}; INPUT.isFiring = false; STATE.manualFirePressed = false;
        }

        // --- LOGIC ---
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function isWater(x, y) {
            if (x < 0 || x >= CONFIG.worldSize || y < 0 || y >= CONFIG.worldSize) return false;
            const idx = Math.floor(y) * CONFIG.worldSize + Math.floor(x);
            return PHYSICS_MAP[idx] === 1;
        }

        function spawnEnemies() {
            ENEMIES = [];
            for(let i=0; i<8; i++) {
                let safe = false, ex, ey, attempts=0;
                while(!safe && attempts<100) {
                    attempts++;
                    ex = Math.random() * CONFIG.worldSize;
                    ey = Math.random() * CONFIG.worldSize;
                    const idx = Math.floor(ey) * CONFIG.worldSize + Math.floor(ex);
                    if (PHYSICS_MAP[idx] === 0 && Math.hypot(ex-PLAYER.x, ey-PLAYER.y) > 600) safe = true;
                }
                if (safe) ENEMIES.push({ x: ex, y: ey, angle: 0, cooldown: Math.random()*2, hp: 3, maxHp: 3, radius: 20 });
            }
        }

        function update(dt) {
            if (!STATE.gameStarted || STATE.isPaused || STATE.gameOver) return;
            if (dt > 0.1) dt = 0.1;

            // Inputs
            if (STATE.isMobile) {
                if (INPUT.touches.leftId !== null) {
                    const dx = INPUT.touches.leftCurr.x - INPUT.touches.leftStart.x;
                    const dy = INPUT.touches.leftCurr.y - INPUT.touches.leftStart.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist > 0) {
                        const power = Math.min(dist, 50) / 50;
                        INPUT.moveVector = { x: (dx/dist)*power, y: (dy/dist)*power };
                    }
                }
                if (INPUT.touches.rightId !== null) {
                    const dx = INPUT.touches.rightCurr.x - INPUT.touches.rightStart.x;
                    const dy = INPUT.touches.rightCurr.y - INPUT.touches.rightStart.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if ((dist / 50) > CONFIG.joystickDeadzone) INPUT.aimAngle = Math.atan2(dy, dx);
                    if (STATE.autoFireMode === 0) INPUT.isFiring = true;
                    else if (STATE.autoFireMode === 1) INPUT.isFiring = (dist / 50) > CONFIG.joystickDeadzone;
                    else INPUT.isFiring = STATE.manualFirePressed;
                } else INPUT.isFiring = STATE.manualFirePressed;
            } else {
                INPUT.moveVector = {x:0, y:0};
                if (INPUT.keys['w'] || INPUT.keys['arrowup']) INPUT.moveVector.y = -1;
                if (INPUT.keys['s'] || INPUT.keys['arrowdown']) INPUT.moveVector.y = 1;
                if (INPUT.keys['a'] || INPUT.keys['arrowleft']) INPUT.moveVector.x = -1;
                if (INPUT.keys['d'] || INPUT.keys['arrowright']) INPUT.moveVector.x = 1;
                if (INPUT.moveVector.x !== 0 || INPUT.moveVector.y !== 0) {
                    const len = Math.sqrt(INPUT.moveVector.x**2 + INPUT.moveVector.y**2);
                    INPUT.moveVector.x /= len; INPUT.moveVector.y /= len;
                }
                INPUT.aimAngle = Math.atan2((INPUT.mouse.y + CAMERA.y) - PLAYER.y, (INPUT.mouse.x + CAMERA.x) - PLAYER.x);
                INPUT.isFiring = INPUT.mouse.down;
            }

            if (INPUT.moveVector.x !== 0 || INPUT.moveVector.y !== 0) PLAYER.bodyAngle = Math.atan2(INPUT.moveVector.y, INPUT.moveVector.x);
            PLAYER.turretAngle = INPUT.aimAngle;

            // Physics
            let speed = CONFIG.playerSpeed;
            if (isWater(PLAYER.x, PLAYER.y)) {
                speed *= CONFIG.waterSpeedMult;
                if (!STATE.wasInWater) playSound('splash');
                if ((INPUT.moveVector.x !== 0 || INPUT.moveVector.y !== 0) && Math.random() < 0.3) {
                    PARTICLES.push({x: PLAYER.x + (Math.random()-0.5)*20, y: PLAYER.y + (Math.random()-0.5)*20, size: 3+Math.random()*4, life: 0.5, color: 'rgba(200,240,255,0.6)'});
                }
            }
            STATE.wasInWater = isWater(PLAYER.x, PLAYER.y);

            PLAYER.x += INPUT.moveVector.x * speed * dt;
            PLAYER.y += INPUT.moveVector.y * speed * dt;
            PLAYER.x = Math.max(20, Math.min(CONFIG.worldSize-20, PLAYER.x));
            PLAYER.y = Math.max(20, Math.min(CONFIG.worldSize-20, PLAYER.y));

            // Camera
            const tx = PLAYER.x - canvas.width/2;
            const ty = PLAYER.y - canvas.height/2;
            const damp = 1 - Math.exp(-CONFIG.cameraDamping * dt);
            CAMERA.x += (tx - CAMERA.x) * damp;
            CAMERA.y += (ty - CAMERA.y) * damp;

            // Combat
            if (PLAYER.cooldown > 0) PLAYER.cooldown -= dt;
            if (INPUT.isFiring && PLAYER.cooldown <= 0) {
                fireWeapon(PLAYER, 'player');
                PLAYER.cooldown = CONFIG.fireRate;
            }

            // Shops Logic
            shopTimer += dt;
            let onShop = false;
            if (shopTimer >= 0.5) { // Check twice a second
                shopTimer = 0;
                for (let s of SHOPS) {
                    if (PLAYER.x > s.x && PLAYER.x < s.x + s.w && PLAYER.y > s.y && PLAYER.y < s.y + s.h) {
                        onShop = true;
                        if (!s.unlocked) {
                            if (PLAYER.cash >= s.price) {
                                PLAYER.cash -= s.price;
                                s.unlocked = true;
                                playSound('pickup');
                                updateHUD();
                            } else {
                                showZoneMsg(`Unlock: $${s.price}`);
                            }
                        } else {
                            // Active Shop Effect
                            if (s.type === 'med') {
                                if (PLAYER.hp < PLAYER.maxHp) { PLAYER.hp++; playSound('pickup'); updateHUD(); }
                                else showZoneMsg("HP Full");
                            } else if (s.type === 'cash') {
                                PLAYER.cash += 0.1; // Small stream
                                updateHUD();
                            }
                        }
                    }
                }
            }
            if (!onShop) document.getElementById('hud-zone-msg').style.opacity = 0;

            // Entities
            updateEntities(dt);
        }

        function showZoneMsg(msg) {
            const el = document.getElementById('hud-zone-msg');
            el.innerText = msg;
            el.style.opacity = 1;
        }

        function updateEntities(dt) {
            for (let i = ENEMIES.length - 1; i >= 0; i--) {
                let e = ENEMIES[i];
                if (Math.hypot(PLAYER.x - e.x, PLAYER.y - e.y) < 600) {
                    e.angle = Math.atan2(PLAYER.y - e.y, PLAYER.x - e.x);
                    if (e.cooldown > 0) e.cooldown -= dt;
                    if (e.cooldown <= 0) { fireWeapon(e, 'enemy'); e.cooldown = 1.5 + Math.random(); }
                }
            }
            for (let i = BULLETS.length - 1; i >= 0; i--) {
                let b = BULLETS[i];
                b.x += b.vx * dt; b.y += b.vy * dt; b.life -= dt;
                let hit = false;
                if (b.owner === 'player') {
                    for (let j = ENEMIES.length - 1; j >= 0; j--) {
                        let e = ENEMIES[j];
                        if (Math.hypot(b.x - e.x, b.y - e.y) < 25) {
                            e.hp--; hit = true; playSound('hit_enemy');
                            if (e.hp <= 0) { dropLoot(e.x, e.y); ENEMIES.splice(j, 1); }
                            break;
                        }
                    }
                } else if (b.owner === 'enemy') {
                    if (Math.hypot(b.x - PLAYER.x, b.y - PLAYER.y) < 25) {
                        PLAYER.hp--; updateHUD(); hit = true; playSound('hit_player');
                        if (PLAYER.hp <= 0) doGameOver();
                    }
                }
                if (b.life <= 0 || hit) BULLETS.splice(i, 1);
            }
            for (let i = LOOT.length - 1; i >= 0; i--) {
                let l = LOOT[i];
                if (Math.hypot(PLAYER.x - l.x, PLAYER.y - l.y) < 30) {
                    playSound('pickup');
                    if (l.type === 0 && PLAYER.hp < PLAYER.maxHp) PLAYER.hp++;
                    else if (l.type === 1) PLAYER.cash += 1;
                    else if (l.type === 2) PLAYER.cash += 5;
                    else if (l.type === 3) PLAYER.cash += l.value;
                    updateHUD();
                    LOOT.splice(i, 1);
                }
            }
            for (let i = PARTICLES.length - 1; i >= 0; i--) {
                let p = PARTICLES[i];
                p.life -= dt;
                if (p.life <= 0) PARTICLES.splice(i, 1);
            }
        }

        function fireWeapon(source, type) {
            if (type === 'player') playSound('shoot'); else playSound('enemy_shoot');
            const angle = (type === 'player') ? source.turretAngle : source.angle;
            BULLETS.push({ x: source.x + Math.cos(angle)*35, y: source.y + Math.sin(angle)*35, vx: Math.cos(angle)*CONFIG.bulletSpeed, vy: Math.sin(angle)*CONFIG.bulletSpeed, life: CONFIG.bulletLife, owner: type });
        }

        function dropLoot(x, y) {
            const rand = Math.random();
            let type = (PLAYER.hp === PLAYER.maxHp) ? (rand < 0.49 ? 2 : 1) : (rand < 0.33 ? 0 : rand < 0.66 ? 2 : 1);
            LOOT.push({ x, y, type });
        }

        function updateHUD() {
            const pct = (PLAYER.hp / PLAYER.maxHp) * 100;
            document.getElementById('hud-hp-fill').style.width = `${pct}%`;
            document.getElementById('hud-hp-text').innerText = `${PLAYER.hp}/${PLAYER.maxHp}`;
            document.getElementById('hud-cash').innerText = "$" + PLAYER.cash.toFixed(1);
        }

        function doGameOver() {
            STATE.gameOver = true;
            if (PLAYER.cash > 0) { LOOT.push({ x: PLAYER.x, y: PLAYER.y, type: 3, value: PLAYER.cash }); PLAYER.cash = 0; updateHUD(); }
            document.getElementById('game-over-screen').style.display = 'flex';
        }

        function respawn() {
            PLAYER.hp = 3; PLAYER.x = 1600; PLAYER.y = 1600; STATE.gameOver = false; BULLETS = []; updateHUD();
            document.getElementById('game-over-screen').style.display = 'none';
            resetInputs(); CAMERA.x = PLAYER.x - canvas.width/2; CAMERA.y = PLAYER.y - canvas.height/2;
        }

        // --- DRAW ---
        function draw() {
            // Fill Void
            ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (!worldCanvas) return;

            ctx.save();
            ctx.translate(-CAMERA.x, -CAMERA.y);

            // Background
            ctx.drawImage(worldCanvas, 0, 0);
            
            // Grid (Optional)
            if (STATE.showGrid) {
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                for (let x = 0; x <= CONFIG.worldSize; x += 64) { ctx.moveTo(x, 0); ctx.lineTo(x, CONFIG.worldSize); }
                for (let y = 0; y <= CONFIG.worldSize; y += 64) { ctx.moveTo(0, y); ctx.lineTo(CONFIG.worldSize, y); }
                ctx.stroke();
            }

            // Shops
            for (let s of SHOPS) {
                // Glow if unlocked
                if (s.unlocked) {
                    ctx.shadowBlur = 15; ctx.shadowColor = s.id === 'med' ? '#f00' : '#0f0';
                }
                ctx.fillStyle = s.color;
                ctx.fillRect(s.x, s.y, s.w, s.h);
                ctx.shadowBlur = 0; // Reset
                ctx.fillStyle = '#fff';
                ctx.font = "bold 30px Arial";
                ctx.textAlign = "center";
                ctx.fillText(s.icon, s.x + s.w/2, s.y + s.h/2 + 10);
            }

            // Loot
            for (let l of LOOT) {
                ctx.save(); ctx.translate(l.x, l.y);
                ctx.shadowBlur = 10;
                if (l.type === 0) { ctx.fillStyle = '#ff3333'; ctx.shadowColor = '#f00'; ctx.font = "24px Arial"; ctx.fillText("â¤", -12, 8); }
                else if (l.type === 1) { ctx.fillStyle = '#81C784'; ctx.shadowColor = '#0f0'; ctx.fillRect(-8, -12, 16, 24); ctx.fillStyle='#000'; ctx.font="12px monospace"; ctx.fillText("$1", -6, 4); }
                else if (l.type === 2) { ctx.fillStyle = '#4CAF50'; ctx.shadowColor = '#0f0'; ctx.fillRect(-10, -14, 20, 28); ctx.fillStyle='#000'; ctx.font="12px monospace"; ctx.fillText("$5", -7, 4); }
                else if (l.type === 3) { ctx.fillStyle = '#FFD700'; ctx.shadowColor = '#ff0'; ctx.beginPath(); ctx.arc(0,0,15,0,Math.PI*2); ctx.fill(); }
                ctx.restore();
            }

            // Particles
            ctx.shadowBlur = 0;
            for (let p of PARTICLES) {
                ctx.fillStyle = p.color; ctx.globalAlpha = p.life * 2;
                ctx.fillRect(p.x, p.y, p.size, p.size); ctx.globalAlpha = 1.0;
            }

            // Enemies (2.5D)
            for (let e of ENEMIES) {
                drawTank(e.x, e.y, e.angle, CONFIG.colors.enemyBody, '#5D4037', false);
                // HP Bar
                ctx.fillStyle = '#000'; ctx.fillRect(e.x-15, e.y-40, 30, 4);
                ctx.fillStyle = '#f00'; ctx.fillRect(e.x-15, e.y-40, 30 * (e.hp/e.maxHp), 4);
            }

            // Bullets (Glowing)
            ctx.lineWidth = 3;
            for (let b of BULLETS) {
                ctx.strokeStyle = (b.owner === 'player') ? '#FFEB3B' : '#FF5252';
                ctx.shadowBlur = 10; ctx.shadowColor = ctx.strokeStyle;
                ctx.beginPath();
                ctx.moveTo(b.x - b.vx*0.02, b.y - b.vy*0.02);
                ctx.lineTo(b.x, b.y);
                ctx.stroke();
            }
            ctx.shadowBlur = 0;

            // Player (2.5D)
            drawTank(PLAYER.x, PLAYER.y, PLAYER.bodyAngle, CONFIG.colors.tankBody, CONFIG.colors.tankTurret, true, PLAYER.turretAngle);

            ctx.restore();

            // UI
            if (STATE.gameStarted && !STATE.isPaused && !STATE.gameOver && STATE.isMobile) {
                if (INPUT.touches.leftId !== null) drawJoystick(INPUT.touches.leftStart, INPUT.touches.leftCurr);
                if (INPUT.touches.rightId !== null) drawJoystick(INPUT.touches.rightStart, INPUT.touches.rightCurr);
            }
        }

        function drawTank(x, y, angle, bodyColor, turretColor, isPlayer, turretAngle) {
            ctx.save();
            ctx.translate(x, y);
            
            // Drop Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.beginPath(); ctx.ellipse(5, 5, 20, 20, 0, 0, Math.PI*2); ctx.fill();

            // Body
            ctx.rotate(angle);
            // Treads
            ctx.fillStyle = '#111';
            ctx.fillRect(-22, -22, 44, 6); ctx.fillRect(-22, 16, 44, 6);
            
            // Main Chassis (Gradient for 3D)
            const bodyGrad = ctx.createLinearGradient(0, -18, 0, 18);
            bodyGrad.addColorStop(0, bodyColor);
            bodyGrad.addColorStop(0.5, lighten(bodyColor, 20));
            bodyGrad.addColorStop(1, bodyColor);
            ctx.fillStyle = bodyGrad;
            ctx.fillRect(-20, -18, 40, 36);
            
            // Detail Lines
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(-15, -10, 5, 20); ctx.fillRect(10, -10, 5, 20);

            ctx.restore();

            // Turret (Independent Rotation)
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(isPlayer ? turretAngle : angle);
            
            // Barrel
            ctx.fillStyle = '#263238';
            ctx.fillRect(0, -5, 38, 10);
            
            // Dome
            const turretGrad = ctx.createRadialGradient(-5, -5, 2, 0, 0, 15);
            turretGrad.addColorStop(0, lighten(turretColor, 30));
            turretGrad.addColorStop(1, turretColor);
            ctx.fillStyle = turretGrad;
            ctx.beginPath(); ctx.arc(0, 0, 12, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = '#263238'; ctx.lineWidth = 1; ctx.stroke();

            ctx.restore();
        }

        // Helper to lighten hex color
        function lighten(color, percent) {
            const num = parseInt(color.replace("#",""),16),
            amt = Math.round(2.55 * percent),
            R = (num >> 16) + amt,
            B = (num >> 8 & 0x00FF) + amt,
            G = (num & 0x0000FF) + amt;
            return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 + (B<255?B<1?0:B:255)*0x100 + (G<255?G<1?0:G:255)).toString(16).slice(1);
        }

        function drawJoystick(start, curr) {
            ctx.beginPath(); ctx.arc(start.x, start.y, 50, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)'; ctx.lineWidth = 2; ctx.stroke();
            ctx.beginPath(); ctx.arc(curr.x, curr.y, 25, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)'; ctx.fill();
        }

        function setupUI() {
            const bindBtn = (id, cb) => {
                const el = document.getElementById(id);
                const h = (e) => { e.preventDefault(); e.stopPropagation(); cb(el); return false; };
                el.addEventListener('touchend', h, {passive:false}); el.addEventListener('click', h);
            };
            const bindPress = (id, start, end) => {
                const el = document.getElementById(id);
                const s = (e) => { e.preventDefault(); e.stopPropagation(); start(); };
                const f = (e) => { e.preventDefault(); e.stopPropagation(); end(); };
                el.addEventListener('touchstart', s, {passive:false}); el.addEventListener('mousedown', s);
                el.addEventListener('touchend', f, {passive:false}); el.addEventListener('mouseup', f);
            };

            bindBtn('btn-respawn', respawn);
            bindBtn('pause-btn', () => togglePause(true));
            bindBtn('btn-close-pause', () => togglePause(false));
            
            const overlay = document.getElementById('pause-overlay');
            const closeBg = (e) => { if (e.target === overlay) { e.preventDefault(); togglePause(false); }};
            overlay.addEventListener('touchend', closeBg); overlay.addEventListener('click', closeBg);

            bindBtn('btn-toggle-fps', (el) => {
                STATE.showFPS = !STATE.showFPS;
                document.getElementById('top-left-info').style.display = STATE.showFPS ? 'flex' : 'none';
                el.innerText = `Show FPS: ${STATE.showFPS ? 'ON' : 'OFF'}`;
                el.classList.toggle('active');
            });
            bindBtn('btn-toggle-grid', (el) => {
                STATE.showGrid = !STATE.showGrid;
                el.innerText = `Show Grid: ${STATE.showGrid ? 'ON' : 'OFF'}`;
                el.classList.toggle('active');
            });
            bindBtn('btn-auto-fire', (el) => {
                STATE.autoFireMode = (STATE.autoFireMode + 1) % 3;
                if (STATE.autoFireMode === 0) { el.innerText = `Auto-Fire: ANY`; document.getElementById('autofire-desc').innerText = "Fires on touch."; }
                else if (STATE.autoFireMode === 1) { el.innerText = `Auto-Fire: AIMING`; document.getElementById('autofire-desc').innerText = "Fires when aiming."; }
                else { el.innerText = `Auto-Fire: OFF`; document.getElementById('autofire-desc').innerText = "Use fire button."; }
                updateManualFireButton();
            });
            bindBtn('btn-toggle-debug', (el) => {
                STATE.showDebug = !STATE.showDebug;
                document.getElementById('debug-overlay').style.display = STATE.showDebug ? 'block' : 'none';
                document.getElementById('btn-copy-log').style.display = STATE.showDebug ? 'block' : 'none';
                el.classList.toggle('active');
            });
            bindBtn('btn-copy-log', () => navigator.clipboard.writeText(DEBUG_LOG.join('\n')));
            bindPress('btn-manual-fire', () => STATE.manualFirePressed = true, () => STATE.manualFirePressed = false);
        }

        function togglePause(pause) {
            STATE.isPaused = pause;
            document.getElementById('pause-modal').style.display = pause ? 'block' : 'none';
            document.getElementById('pause-overlay').style.display = pause ? 'block' : 'none';
            if (!pause) STATE.lastTime = performance.now();
        }

        function gameLoop(timestamp) {
            if (!STATE.lastTime) STATE.lastTime = timestamp;
            const dt = (timestamp - STATE.lastTime) / 1000;
            STATE.lastTime = timestamp;
            update(dt);
            draw();
            // FPS
            if (STATE.showFPS && dt > 0) {
                FPS.buffer.push(1/dt);
                if (FPS.buffer.length > 30) FPS.buffer.shift();
                if (timestamp - FPS.lastUpdate >= 500) {
                    const avg = Math.round(FPS.buffer.reduce((a,b)=>a+b,0)/FPS.buffer.length);
                    const low = Math.round([...FPS.buffer].sort((a,b)=>a-b)[0]);
                    document.getElementById('fps-counter').innerText = `FPS: ${avg} (Low: ${low})`;
                    FPS.lastUpdate = timestamp;
                }
            }
            requestAnimationFrame(gameLoop);
        }

        init();
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TTR v23</title>
    <link rel="icon" href="data:,">
    <style>
        /* CORE STYLES */
        body { margin: 0; padding: 0; background-color: #111; overflow: hidden; touch-action: none; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: #eee; user-select: none; -webkit-user-select: none; }
        canvas { display: block; }

        /* UI OVERLAY */
        #ui-layer { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .hud-text { text-shadow: 1px 1px 2px #000; font-weight: 600; pointer-events: auto; letter-spacing: 1px; }
        #top-left-info { position: absolute; top: 15px; left: 15px; display: flex; gap: 15px; font-size: 12px; color: #aaa; pointer-events: none; }

        /* HP BAR */
        #hud-hp-container { position: absolute; top: 15px; right: 60px; width: 220px; height: 28px; background: #000; border: 2px solid #444; border-radius: 2px; box-shadow: 0 2px 5px rgba(0,0,0,0.5); }
        #hud-hp-fill { width: 100%; height: 100%; background: linear-gradient(180deg, #4CAF50, #2E7D32); transition: width 0.2s; }
        #hud-hp-text { position: absolute; top: 0; left: 0; width: 100%; line-height: 28px; text-align: center; font-size: 14px; color: #fff; text-shadow: 1px 1px 2px #000; }
        #hud-cash { position: absolute; top: 50px; right: 60px; font-size: 20px; color: #81C784; text-align: right; font-family: monospace; }
        #hud-zone-msg { position: absolute; top: 20%; width: 100%; text-align: center; font-size: 18px; color: #FFD700; text-shadow: 0 2px 4px #000; opacity: 0; transition: opacity 0.3s; }

        #pause-btn { position: absolute; top: 15px; right: 15px; cursor: pointer; font-size: 24px; line-height: 28px; width: 32px; height: 32px; text-align: center; background: rgba(0,0,0,0.5); border: 1px solid #666; border-radius: 4px; pointer-events: auto; }

        /* MANUAL FIRE BUTTON */
        #btn-manual-fire { display: none; position: absolute; bottom: 20%; right: 15%; width: 90px; height: 90px; background: radial-gradient(circle, rgba(255, 80, 80, 0.6) 0%, rgba(200, 40, 40, 0.8) 100%); border: 3px solid rgba(255, 255, 255, 0.3); border-radius: 50%; pointer-events: auto; touch-action: manipulation; box-shadow: 0 4px 10px rgba(0,0,0,0.6); }
        #btn-manual-fire:active { transform: scale(0.95); filter: brightness(1.2); }

        /* MODALS */
        .fullscreen-modal { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #111; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 50; pointer-events: auto; }
        h1 { margin: 0 0 20px 0; color: #ccc; text-transform: uppercase; letter-spacing: 4px; font-weight: 300; border-bottom: 1px solid #444; padding-bottom: 10px;}
        .big-btn { padding: 15px 50px; font-size: 20px; background: linear-gradient(180deg, #333, #222); color: #ddd; border: 1px solid #555; border-radius: 2px; cursor: pointer; font-weight: bold; box-shadow: 0 4px 10px rgba(0,0,0,0.5); touch-action: manipulation; text-transform: uppercase; letter-spacing: 1px; }
        .big-btn:active { background: #444; transform: translateY(2px); }
        #loading-bar-container { width: 60%; height: 10px; background: #222; border: 1px solid #444; margin-top: 20px; display: none; }
        #loading-bar-fill { width: 0%; height: 100%; background: #4CAF50; transition: width 0.1s; }
        #loading-text { color: #666; font-size: 12px; margin-top: 5px; min-height: 15px; visibility: hidden;}

        /* PAUSE MENU */
        #pause-modal { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(30, 30, 30, 0.95); border: 1px solid #555; padding: 20px; text-align: center; min-width: 300px; max-height: 80vh; overflow-y: auto; box-shadow: 0 10px 30px rgba(0,0,0,0.8); z-index: 20; pointer-events: auto; }
        #pause-overlay { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 10; pointer-events: auto; }
        .modal-btn { display: block; width: 100%; margin: 8px 0; padding: 12px; background: #333; color: #ccc; border: 1px solid #555; cursor: pointer; font-family: inherit; font-size: 14px; touch-action: manipulation; }
        .modal-btn.active { background: #2E7D32; color: #fff; border-color: #4CAF50; }
        .modal-desc { font-size: 11px; color: #888; margin-bottom: 10px; font-style: italic; }
        #btn-copy-log { display: none; }
        
        /* DEBUG & CRASH */
        #debug-overlay { display: none; position: absolute; bottom: 0; left: 0; width: 100%; height: 30%; background: rgba(0,0,0,0.8); color: #0f0; font-family: monospace; overflow-y: scroll; font-size: 11px; box-sizing: border-box; padding: 5px; z-index: 100; pointer-events: none; user-select: none; border-top: 1px solid #0f0; }
        #debug-overlay.interactive { pointer-events: auto; user-select: text; -webkit-user-select: text; }
        #crash-screen { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #500; z-index: 10000; flex-direction: column; justify-content: center; align-items: center; padding: 20px; box-sizing: border-box; }
        #crash-log { width: 90%; height: 50%; background: #200; color: #fff; border: 1px solid #f88; font-family: monospace; padding: 10px; margin-bottom: 20px; font-size: 10px; }
        #btn-copy-crash { padding: 15px 30px; background: #fff; color: #900; border: none; font-weight: bold; cursor: pointer; }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <!-- CRASH SCREEN -->
    <div id="crash-screen">
        <h1 style="color:white; border:none;">FATAL ERROR</h1>
        <textarea id="crash-log" readonly></textarea>
        <button id="btn-copy-crash">COPY ERROR LOG</button>
        <p style="color:#faa; font-size:12px; margin-top:10px;">Please send this log to the developer.</p>
    </div>

    <!-- START SCREEN -->
    <div id="start-screen" class="fullscreen-modal">
        <h1>Tank Tycoon</h1>
        <button id="btn-start" class="big-btn">INITIALIZE</button>
        <div id="loading-bar-container"><div id="loading-bar-fill"></div></div>
        <div id="loading-text">Generating World...</div>
    </div>

    <!-- GAME OVER SCREEN -->
    <div id="game-over-screen" class="fullscreen-modal" style="display:none;">
        <h1 style="color: #ff3333; border-color: #ff3333;">CRITICAL FAILURE</h1>
        <button id="btn-respawn" class="big-btn" style="background: #500; border-color: #f00;">REDEPLOY</button>
    </div>

    <div id="ui-layer">
        <div id="top-left-info"><span id="version-display">v23</span> <span id="fps-counter">FPS: --</span></div>
        <div id="hud-hp-container"><div id="hud-hp-fill"></div><div id="hud-hp-text">5/5</div></div>
        <div id="hud-cash">$0</div>
        <div id="hud-zone-msg"></div>
        <div id="pause-btn">&#10074;&#10074;</div>
        <div id="btn-manual-fire"></div>
        <div id="pause-overlay"></div>
        <div id="pause-modal">
            <h3 style="color:#ccc; margin-top:0;">SYSTEM PAUSED</h3>
            <button id="btn-toggle-fps" class="modal-btn active">Show FPS: ON</button>
            <button id="btn-auto-fire" class="modal-btn active">Auto-Fire: ANY</button>
            <div id="autofire-desc" class="modal-desc">Fires when right stick is touched.</div>
            <button id="btn-static-joy" class="modal-btn">Static Joysticks: OFF</button>
            <div class="modal-desc">Fixes controls to bottom corners.</div>
            <button id="btn-tap-fire" class="modal-btn">Tap to Fire: OFF</button>
            <div class="modal-desc">Tap screen to aim & shoot (Mobile).</div>
            <button id="btn-toggle-debug" class="modal-btn">Show Live Debug: OFF</button>
            <button id="btn-copy-log" class="modal-btn">Copy Log</button>
            <hr style="border-color:#444; margin: 15px 0;">
            <button id="btn-clear-settings" class="modal-btn" style="border-color:#884444; color:#daa;">Clear Settings</button>
            <button id="btn-start-over" class="modal-btn" style="border-color:#f00; color:#f88;">Start Over</button>
            <button id="btn-close-pause" class="modal-btn" style="background: #500; border-color: #800; margin-top: 20px;">RESUME</button>
        </div>
        <div id="debug-overlay"></div>
    </div>

    <script>
        /** TTR ENGINE v23 - Strict Linear Ordering & Loop Guards */

        // --- 1. CRASH REPORTER & CONSOLE ---
        const DEBUG_LOG = [];
        const originalLog = console.log;
        const originalWarn = console.warn;
        const originalError = console.error;

        function showCrashScreen(msg) {
            const screen = document.getElementById('crash-screen');
            const textArea = document.getElementById('crash-log');
            if (screen && textArea) {
                screen.style.display = 'flex';
                DEBUG_LOG.push(msg);
                textArea.value = DEBUG_LOG.join('\n');
            }
        }

        function logToOverlay(msg, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const entry = `[${timestamp}] [${type.toUpperCase()}] ${msg}`;
            DEBUG_LOG.push(entry);
            const overlay = document.getElementById('debug-overlay');
            if (overlay) {
                const div = document.createElement('div');
                div.textContent = entry;
                if (type === 'error') div.style.color = '#ff5555';
                if (type === 'warn') div.style.color = '#ffff55';
                overlay.appendChild(div);
                if (type === 'error') overlay.style.display = 'block';
            }
        }

        console.log = function(...args) { originalLog.apply(console, args); logToOverlay(args.join(' '), 'info'); };
        console.warn = function(...args) { originalWarn.apply(console, args); logToOverlay(args.join(' '), 'warn'); };
        console.error = function(...args) { originalError.apply(console, args); logToOverlay(args.join(' '), 'error'); };

        window.onerror = function(msg, url, line) {
            const err = `FATAL: ${msg} (Line ${line})`;
            console.error(err);
            showCrashScreen(err);
            return false;
        };

        // --- 2. CONFIG & STATE ---
        const VERSION = "v23";
        const SETTINGS_KEY = "TTR_SETTINGS";
        const SAVE_KEY = "TTR_SAVE_DATA";
        const CONFIG = {
            worldSize: 3200,
            colors: { land: '#4b5320', landNoise: '#3e4418', waterDeep: '#1a262f', waterShallow: '#2b3e4d', sand: '#d2b48c', sandNoise: '#c2a47c', concrete: '#555555', tankBody: '#37474F', tankTurret: '#546E7A', enemyBody: '#8D6E63' },
            playerSpeed: 250, waterSpeedMult: 0.3, sandSpeedMult: 0.5, fireRate: 1.0, bulletSpeed: 700, bulletLife: 1.5, joystickDeadzone: 0.2, cameraDamping: 10
        };
        const TIERS = {
            cash: [{price:10,rate:0.1},{price:50,rate:0.25},{price:500,rate:1.0},{price:2500,rate:5.0},{price:5000,rate:10.0},{price:25000,rate:100.0},{price:100000,rate:500.0},{price:500000,rate:2500.0},{price:5000000,rate:5000.0},{price:25000000,rate:25000.0}],
            med: [{price:100,rate:1},{price:500,rate:2},{price:1000,rate:3}]
        };
        const STATE = {
            worldReady: false, startOnLoad: false, gameStarted: false, gameOver: false, lastTime: 0, 
            showFPS: true, showDebug: false, autoFireMode: 0, staticJoysticks: false, tapToFire: false,
            savedAutoFire: 0, savedStatic: false, isMobile: false, isPaused: false, audioInitialized: false,
            wasInWater: false, manualFirePressed: false
        };

        // --- 3. LIBRARIES ---
        const Noise = (function() {
            const p = new Uint8Array(512);
            const permutation = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
            for (let i=0; i < 256 ; i++) p[256+i] = p[i] = permutation[i];
            function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            function lerp(t, a, b) { return a + t * (b - a); }
            function grad(hash, x, y, z) { const h = hash & 15; const u = h<8 ? x : y, v = h<4 ? y : h==12||h==14 ? x : z; return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v); }
            return { perlin2: function(x, y) { const X = Math.floor(x) & 255, Y = Math.floor(y) & 255; x -= Math.floor(x); y -= Math.floor(y); const u = fade(x), v = fade(y); const A = p[X]+Y, AA = p[A], AB = p[A+1], B = p[X+1]+Y, BA = p[B], BB = p[B+1]; return lerp(v, lerp(u, grad(p[AA], x, y, 0), grad(p[BA], x-1, y, 0)), lerp(u, grad(p[AB], x, y-1, 0), grad(p[BB], x-1, y-1, 0))); } };
        })();

        // --- 4. UTILS & GLOBALS ---
        const CAMERA = { x: 0, y: 0 };
        const FPS = { buffer: [], lastUpdate: 0, display: "FPS: --" };
        let PHYSICS_MAP = null; 
        let SEED = 1;
        let SHOPS = [
            { id: 'med', type: 'med', x: 1550, y: 1550, w: 60, h: 60, tier: 0, unlocked: false, color: '#444', icon: '+' },
            { id: 'cash', type: 'cash', x: 1650, y: 1550, w: 60, h: 60, tier: 0, unlocked: false, color: '#444', icon: '$' }
        ];
        let shopTimer = 0, enemySpawnTimer = 0, saveTimer = 0;
        let PLAYER = { x: 1600, y: 1600, radius: 20, cooldown: 0, bodyAngle: 0, turretAngle: 0, hp: 5, maxHp: 5, cash: 0, passiveIncome: 0 };
        let BULLETS = [], PARTICLES = [], ENEMIES = [], LOOT = [];
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        let worldCanvas = null;

        function log(msg) { console.log(msg); }
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (!STATE.gameStarted) { CAMERA.x = PLAYER.x - canvas.width/2; CAMERA.y = PLAYER.y - canvas.height/2; }
        }
        function mulberry32(a) {
            return function() {
              var t = a += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61);
              return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }
        let rng = mulberry32(1);
        function formatMoney(amount) {
            if (amount < 1000) return "$" + amount.toFixed(2);
            if (amount < 1000000) return "$" + (amount/1000).toFixed(2) + "k";
            if (amount < 1000000000) return "$" + (amount/1000000).toFixed(2) + "m";
            return "$" + (amount/1000000000).toFixed(2) + "b";
        }
        function lighten(c, p) { const n=parseInt(c.replace("#",""),16),a=Math.round(2.55*p),R=(n>>16)+a,B=(n>>8&0x00FF)+a,G=(n&0x0000FF)+a; return "#"+(0x1000000+(R<255?R<1?0:R:255)*0x10000+(B<255?B<1?0:B:255)*0x100+(G<255?G<1?0:G:255)).toString(16).slice(1); }

        // --- 5. AUDIO ---
        let audioCtx = null;
        let splashBuffer = null;
        let sandBuffer = null;
        function initAudio() {
            if (STATE.audioInitialized) return;
            try {
                const AC = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AC();
                STATE.audioInitialized = true;
                createBuffers();
            } catch (e) { console.error("Audio Error", e); }
        }
        function createBuffers() {
            if (!audioCtx) return;
            let sb = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.5, audioCtx.sampleRate);
            let d = sb.getChannelData(0);
            for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * (1 - i/d.length);
            splashBuffer = sb;
            let sdb = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.2, audioCtx.sampleRate);
            let d2 = sdb.getChannelData(0);
            for (let i = 0; i < d2.length; i++) d2[i] = (Math.random() * 2 - 1) * 0.5;
            sandBuffer = sdb;
        }
        function playSound(type) {
            if (!audioCtx || audioCtx.state !== 'running') return;
            const gain = audioCtx.createGain(); gain.connect(audioCtx.destination);
            const t = audioCtx.currentTime;
            if (type === 'shoot') {
                const o = audioCtx.createOscillator(); o.type = 'square'; o.frequency.setValueAtTime(400, t); o.frequency.exponentialRampToValueAtTime(100, t+0.1);
                gain.gain.setValueAtTime(0.05, t); gain.gain.exponentialRampToValueAtTime(0.01, t+0.1); o.connect(gain); o.start(); o.stop(t+0.1);
            } else if (type === 'enemy_shoot') {
                const o = audioCtx.createOscillator(); o.type = 'triangle'; o.frequency.setValueAtTime(200, t); o.frequency.exponentialRampToValueAtTime(50, t+0.15);
                gain.gain.setValueAtTime(0.06, t); gain.gain.exponentialRampToValueAtTime(0.01, t+0.15); o.connect(gain); o.start(); o.stop(t+0.15);
            } else if (type === 'splash' && splashBuffer) {
                const s = audioCtx.createBufferSource(); s.buffer = splashBuffer; const f = audioCtx.createBiquadFilter(); f.type = "lowpass"; f.frequency.value = 1000;
                s.connect(f); f.connect(gain); gain.gain.value = 0.2; s.start();
            } else if (type === 'sand' && sandBuffer) {
                const s = audioCtx.createBufferSource(); s.buffer = sandBuffer; const f = audioCtx.createBiquadFilter(); f.type = "lowpass"; f.frequency.value = 400;
                s.connect(f); f.connect(gain); gain.gain.value = 0.1; s.start();
            } else if (type === 'pickup') {
                const o = audioCtx.createOscillator(); o.type = 'sine'; o.frequency.setValueAtTime(600, t); o.frequency.linearRampToValueAtTime(1200, t+0.1);
                gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t+0.1); o.connect(gain); o.start(); o.stop(t+0.1);
            }
        }

        // --- 6. PERSISTENCE ---
        function loadSettings() {
            try {
                const saved = localStorage.getItem(SETTINGS_KEY);
                if (saved) {
                    const s = JSON.parse(saved);
                    if (s.showFPS !== undefined) STATE.showFPS = s.showFPS;
                    if (s.autoFireMode !== undefined) STATE.autoFireMode = s.autoFireMode;
                    if (s.staticJoysticks !== undefined) STATE.staticJoysticks = s.staticJoysticks;
                    if (s.tapToFire !== undefined) STATE.tapToFire = s.tapToFire;
                }
            } catch (e) { console.error(e); }
        }
        function loadGame() {
            try {
                const save = localStorage.getItem(SAVE_KEY);
                if (save) {
                    const d = JSON.parse(save);
                    SEED = d.seed; PLAYER = d.player; ENEMIES = d.enemies; LOOT = d.loot; SHOPS = d.shops;
                    console.log("Game Loaded. Seed: " + SEED);
                } else {
                    SEED = Math.floor(Math.random() * 1000000);
                    console.log("New Game. Seed: " + SEED);
                }
                rng = mulberry32(SEED);
            } catch (e) { console.error(e); SEED = Math.floor(Math.random() * 1000000); rng = mulberry32(SEED); }
        }
        function saveGame() {
            const data = { seed: SEED, player: PLAYER, enemies: ENEMIES, loot: LOOT, shops: SHOPS };
            localStorage.setItem(SAVE_KEY, JSON.stringify(data));
            const settings = { showFPS: STATE.showFPS, autoFireMode: STATE.autoFireMode, staticJoysticks: STATE.staticJoysticks, tapToFire: STATE.tapToFire };
            localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
            console.log("Game Saved");
        }
        function startOver() {
            if (confirm("Are you sure? This will delete your world and progress.")) { localStorage.removeItem(SAVE_KEY); location.reload(); }
        }
        function clearSettings() {
            if (confirm("Reset settings to default? World data will be kept.")) { localStorage.removeItem(SETTINGS_KEY); location.reload(); }
        }

        // --- 7. INPUT HELPERS ---
        function resetInputs() {
            INPUT.keys = {}; INPUT.mouse.down = false; 
            INPUT.touches.leftId = null; INPUT.touches.rightId = null; 
            INPUT.moveVector = {x:0,y:0}; INPUT.isFiring = false; 
            STATE.manualFirePressed = false;
        }
        function updateManualFireButton() {
            const btn = document.getElementById('btn-manual-fire');
            btn.style.display = (STATE.isMobile && STATE.autoFireMode === 2 && !STATE.tapToFire) ? 'block' : 'none';
        }

        // --- 8. ENTITY HELPERS ---
        function spawnEnemy() {
            if (!PHYSICS_MAP) return;
            let safe = false, ex, ey, attempts=0;
            while(!safe && attempts<100) {
                attempts++;
                ex = rng() * CONFIG.worldSize;
                ey = rng() * CONFIG.worldSize;
                const idx = Math.max(0, Math.min(Math.floor(ey) * CONFIG.worldSize + Math.floor(ex), CONFIG.worldSize * CONFIG.worldSize - 1));
                if (PHYSICS_MAP && PHYSICS_MAP[idx] !== 1 && Math.hypot(ex-PLAYER.x, ey-PLAYER.y) > 800) safe = true;
            }
            if (safe) ENEMIES.push({ x: ex, y: ey, angle: 0, cooldown: rng()*2, hp: 3, maxHp: 3, radius: 20 });
        }
        function spawnEnemies() {
            if (!PHYSICS_MAP) return;
            ENEMIES = [];
            for(let i=0; i<5; i++) spawnEnemy();
        }
        function fireWeapon(source, type) {
            if (type === 'player') playSound('shoot'); else playSound('enemy_shoot');
            const angle = (type === 'player') ? source.turretAngle : source.angle;
            BULLETS.push({ x: source.x + Math.cos(angle)*35, y: source.y + Math.sin(angle)*35, vx: Math.cos(angle)*CONFIG.bulletSpeed, vy: Math.sin(angle)*CONFIG.bulletSpeed, life: CONFIG.bulletLife, owner: type });
        }
        function dropLoot(x, y) {
            const rand = Math.random();
            let type = (PLAYER.hp === PLAYER.maxHp) ? (rand < 0.49 ? 2 : 1) : (rand < 0.33 ? 0 : rand < 0.66 ? 2 : 1);
            LOOT.push({ x, y, type });
        }
        function updateHUD() {
            const pct = (PLAYER.hp / PLAYER.maxHp) * 100;
            document.getElementById('hud-hp-fill').style.width = `${pct}%`;
            document.getElementById('hud-hp-text').innerText = `${PLAYER.hp.toFixed(1)}/${PLAYER.maxHp}`;
            document.getElementById('hud-cash').innerText = formatMoney(PLAYER.cash);
        }
        function showZoneMsg(msg) {
            const el = document.getElementById('hud-zone-msg'); el.innerText = msg; el.style.opacity = 1;
        }
        function doGameOver() {
            STATE.gameOver = true;
            if (PLAYER.cash > 0) { 
                LOOT.push({ x: PLAYER.x, y: PLAYER.y, type: 3, value: PLAYER.cash });
                const bags = LOOT.filter(l => l.type === 3);
                if (bags.length > 10) { const oldest = bags[0]; const idx = LOOT.indexOf(oldest); if (idx > -1) LOOT.splice(idx, 1); }
                PLAYER.cash = 0; updateHUD(); 
            }
            saveGame();
            document.getElementById('game-over-screen').style.display = 'flex';
        }
        function respawn() {
            PLAYER.hp = 5; PLAYER.x = 1600; PLAYER.y = 1600; STATE.gameOver = false; BULLETS = []; updateHUD();
            document.getElementById('game-over-screen').style.display = 'none';
            resetInputs(); CAMERA.x = PLAYER.x - canvas.width/2; CAMERA.y = PLAYER.y - canvas.height/2;
            saveGame();
        }

        // --- 9. PHYSICS & INPUT HANDLERS ---
        function handleInput(dt) {
            if (STATE.isMobile) {
                if (INPUT.touches.leftId !== null) {
                    const dx = INPUT.touches.leftCurr.x - INPUT.touches.leftStart.x;
                    const dy = INPUT.touches.leftCurr.y - INPUT.touches.leftStart.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist > 0) {
                        const power = Math.min(dist, 50) / 50;
                        INPUT.moveVector = { x: (dx/dist)*power, y: (dy/dist)*power };
                    }
                }
                if (INPUT.touches.rightId !== null) {
                    const start = INPUT.touches.rightStart;
                    const curr = INPUT.touches.rightCurr;
                    const dx = curr.x - start.x, dy = curr.y - start.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const isMoved = (dist / 50) > CONFIG.joystickDeadzone;
                    if (isMoved) { INPUT.aimAngle = Math.atan2(dy, dx); INPUT.lastAimTime = Date.now(); }
                    if (STATE.autoFireMode === 0) INPUT.isFiring = true;
                    else if (STATE.autoFireMode === 1) INPUT.isFiring = isMoved;
                    else if (STATE.autoFireMode === 3) INPUT.isFiring = !isMoved;
                    else INPUT.isFiring = STATE.manualFirePressed;
                } else if (!STATE.tapToFire) { INPUT.isFiring = STATE.manualFirePressed; }
            } else {
                INPUT.moveVector = {x:0, y:0};
                if (INPUT.keys['w'] || INPUT.keys['arrowup']) INPUT.moveVector.y = -1;
                if (INPUT.keys['s'] || INPUT.keys['arrowdown']) INPUT.moveVector.y = 1;
                if (INPUT.keys['a'] || INPUT.keys['arrowleft']) INPUT.moveVector.x = -1;
                if (INPUT.keys['d'] || INPUT.keys['arrowright']) INPUT.moveVector.x = 1;
                if (INPUT.moveVector.x !== 0 || INPUT.moveVector.y !== 0) {
                    const len = Math.sqrt(INPUT.moveVector.x**2 + INPUT.moveVector.y**2);
                    INPUT.moveVector.x /= len; INPUT.moveVector.y /= len;
                }
                INPUT.aimAngle = Math.atan2((INPUT.mouse.y + CAMERA.y) - PLAYER.y, (INPUT.mouse.x + CAMERA.x) - PLAYER.x);
                INPUT.isFiring = INPUT.mouse.down;
            }
            if (INPUT.moveVector.x !== 0 || INPUT.moveVector.y !== 0) PLAYER.bodyAngle = Math.atan2(INPUT.moveVector.y, INPUT.moveVector.x);
            PLAYER.turretAngle = INPUT.aimAngle;
        }

        function handlePhysics(dt) {
            let speed = CONFIG.playerSpeed;
            const gx = Math.max(0, Math.min(Math.floor(PLAYER.x), CONFIG.worldSize-1));
            const gy = Math.max(0, Math.min(Math.floor(PLAYER.y), CONFIG.worldSize-1));
            const biome = PHYSICS_MAP[gy * CONFIG.worldSize + gx];
            
            if (biome === 1) { 
                speed *= CONFIG.waterSpeedMult;
                if (!STATE.wasInWater) playSound('splash');
                if ((INPUT.moveVector.x !== 0 || INPUT.moveVector.y !== 0) && Math.random() < 0.3) PARTICLES.push({x: PLAYER.x+(Math.random()-0.5)*20, y: PLAYER.y+(Math.random()-0.5)*20, size: 3+Math.random()*4, life: 0.5, color: '#81D4FA'});
                STATE.wasInWater = true;
            } else if (biome === 3) {
                speed *= CONFIG.sandSpeedMult;
                if ((INPUT.moveVector.x !== 0 || INPUT.moveVector.y !== 0) && Math.random() < 0.2) {
                    playSound('sand');
                    PARTICLES.push({x: PLAYER.x+(Math.random()-0.5)*20, y: PLAYER.y+(Math.random()-0.5)*20, size: 3+Math.random()*4, life: 0.5, color: '#d2b48c'});
                }
                STATE.wasInWater = false;
            } else STATE.wasInWater = false;

            PLAYER.x += INPUT.moveVector.x * speed * dt;
            PLAYER.y += INPUT.moveVector.y * speed * dt;
            PLAYER.x = Math.max(20, Math.min(CONFIG.worldSize-20, PLAYER.x));
            PLAYER.y = Math.max(20, Math.min(CONFIG.worldSize-20, PLAYER.y));

            const tx = PLAYER.x - canvas.width/2;
            const ty = PLAYER.y - canvas.height/2;
            const damp = 1 - Math.exp(-CONFIG.cameraDamping * dt);
            CAMERA.x += (tx - CAMERA.x) * damp;
            CAMERA.y += (ty - CAMERA.y) * damp;

            if (PLAYER.cooldown > 0) PLAYER.cooldown -= dt;
            if (INPUT.isFiring && PLAYER.cooldown <= 0) {
                fireWeapon(PLAYER, 'player');
                PLAYER.cooldown = CONFIG.fireRate;
            }
        }

        function checkShops() {
            let onShop = false;
            for (let s of SHOPS) {
                if (PLAYER.x > s.x && PLAYER.x < s.x + s.w && PLAYER.y > s.y && PLAYER.y < s.y + s.h) {
                    onShop = true;
                    // Track entry to allow drive-off/drive-on
                    if (!s._wasOn) {
                        s._wasOn = true;
                        if (!s.unlocked) {
                            if (PLAYER.cash >= s.price) {
                                PLAYER.cash -= s.price; s.unlocked = true;
                                if (s.type === 'cash') PLAYER.passiveIncome += 0.1;
                                playSound('pickup');
                            } else showZoneMsg(`Unlock: ${formatMoney(s.price)}`);
                        } else {
                            let nextTier;
                            if (s.type === 'cash' && s.tier < TIERS.cash.length - 1) nextTier = TIERS.cash[s.tier + 1];
                            else if (s.type === 'med' && s.tier < TIERS.med.length - 1) nextTier = TIERS.med[s.tier + 1];

                            if (nextTier) {
                                if (PLAYER.cash >= nextTier.price) {
                                    PLAYER.cash -= nextTier.price;
                                    s.tier++;
                                    if (s.type === 'cash') PLAYER.passiveIncome = nextTier.rate;
                                    playSound('pickup');
                                } else showZoneMsg(`Upgrade T${s.tier+1}: ${formatMoney(nextTier.price)}`);
                            }
                        }
                    }
                    if (s.type === 'med' && s.unlocked) {
                        const healRate = TIERS.med[s.tier].rate;
                        if (PLAYER.hp < PLAYER.maxHp) PLAYER.hp = Math.min(PLAYER.maxHp, PLAYER.hp + (healRate * 0.2));
                    }
                } else {
                    s._wasOn = false;
                }
            }
            if (!onShop) document.getElementById('hud-zone-msg').style.opacity = 0;
        }

        function updateEntities(dt) {
            for (let i = ENEMIES.length - 1; i >= 0; i--) {
                let e = ENEMIES[i];
                if (Math.hypot(PLAYER.x - e.x, PLAYER.y - e.y) < 600) {
                    e.angle = Math.atan2(PLAYER.y - e.y, PLAYER.x - e.x);
                    if (e.cooldown > 0) e.cooldown -= dt;
                    if (e.cooldown <= 0) { fireWeapon(e, 'enemy'); e.cooldown = 1.5 + Math.random(); }
                }
            }
            for (let i = BULLETS.length - 1; i >= 0; i--) {
                let b = BULLETS[i];
                b.x += b.vx * dt; b.y += b.vy * dt; b.life -= dt;
                let hit = false;
                if (b.owner === 'player') {
                    for (let j = ENEMIES.length - 1; j >= 0; j--) {
                        let e = ENEMIES[j];
                        if (Math.hypot(b.x - e.x, b.y - e.y) < 25) {
                            e.hp--; hit = true; playSound('hit_enemy');
                            if (e.hp <= 0) { dropLoot(e.x, e.y); ENEMIES.splice(j, 1); }
                            break;
                        }
                    }
                } else if (b.owner === 'enemy') {
                    if (Math.hypot(b.x - PLAYER.x, b.y - PLAYER.y) < 25) {
                        PLAYER.hp--; updateHUD(); hit = true; playSound('hit_player');
                        if (PLAYER.hp <= 0) doGameOver();
                    }
                }
                if (b.life <= 0 || hit) BULLETS.splice(i, 1);
            }
            for (let i = LOOT.length - 1; i >= 0; i--) {
                let l = LOOT[i];
                if (Math.hypot(PLAYER.x - l.x, PLAYER.y - l.y) < 30) {
                    playSound('pickup');
                    if (l.type === 0 && PLAYER.hp < PLAYER.maxHp) PLAYER.hp = Math.min(PLAYER.maxHp, PLAYER.hp + 1);
                    else if (l.type === 1) PLAYER.cash += 1;
                    else if (l.type === 2) PLAYER.cash += 5;
                    else if (l.type === 3) PLAYER.cash += l.value;
                    updateHUD();
                    LOOT.splice(i, 1);
                }
            }
            for (let i = PARTICLES.length - 1; i >= 0; i--) {
                let p = PARTICLES[i];
                p.life -= dt;
                if (p.life <= 0) PARTICLES.splice(i, 1);
            }
        }

        // --- 10. RENDER HELPERS ---
        function drawTank(x, y, angle, bodyColor, turretColor, isPlayer, turretAngle) {
            ctx.save(); ctx.translate(x, y);
            ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.beginPath(); ctx.ellipse(5, 5, 20, 20, 0, 0, Math.PI*2); ctx.fill();
            ctx.rotate(angle);
            ctx.fillStyle = '#111'; ctx.fillRect(-22, -22, 44, 6); ctx.fillRect(-22, 16, 44, 6);
            const bodyGrad = ctx.createLinearGradient(0, -18, 0, 18);
            bodyGrad.addColorStop(0, bodyColor); bodyGrad.addColorStop(0.5, lighten(bodyColor, 20)); bodyGrad.addColorStop(1, bodyColor);
            ctx.fillStyle = bodyGrad; ctx.fillRect(-20, -18, 40, 36);
            ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.fillRect(-15, -10, 5, 20); ctx.fillRect(10, -10, 5, 20);
            ctx.restore();
            ctx.save(); ctx.translate(x, y); ctx.rotate(isPlayer ? turretAngle : angle);
            ctx.fillStyle = '#263238'; ctx.fillRect(0, -5, 38, 10);
            const turretGrad = ctx.createRadialGradient(-5, -5, 2, 0, 0, 15);
            turretGrad.addColorStop(0, lighten(turretColor, 30)); turretGrad.addColorStop(1, turretColor);
            ctx.fillStyle = turretGrad; ctx.beginPath(); ctx.arc(0, 0, 12, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = '#263238'; ctx.lineWidth = 1; ctx.stroke();
            ctx.restore();
        }
        function drawJoystick(start, curr) {
            ctx.beginPath(); ctx.arc(start.x, start.y, 50, 0, Math.PI*2); ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.lineWidth=2; ctx.stroke();
            ctx.beginPath(); ctx.arc(curr.x, curr.y, 25, 0, Math.PI*2); ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.fill();
        }

        // --- 11. CORE LOOP ---
        function update(dt) {
            if (!STATE.gameStarted || STATE.isPaused || STATE.gameOver) return;
            if (!PHYSICS_MAP || !worldCanvas) return;
            if (dt > 0.1) dt = 0.1;

            handleInput(dt);
            handlePhysics(dt);
            
            shopTimer += dt;
            if (PLAYER.passiveIncome > 0) PLAYER.cash += PLAYER.passiveIncome * dt;
            if (shopTimer >= 0.2) { shopTimer = 0; updateHUD(); checkShops(); }
            enemySpawnTimer += dt;
            if (enemySpawnTimer > 5) { enemySpawnTimer = 0; if (ENEMIES.length < 5) spawnEnemy(); }
            saveTimer += dt;
            if (saveTimer > 10) { saveTimer = 0; saveGame(); }

            updateEntities(dt);
        }

        function draw() {
            if (!worldCanvas) return;
            ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(-CAMERA.x, -CAMERA.y);
            ctx.drawImage(worldCanvas, 0, 0);

            for (let s of SHOPS) {
                if (s.unlocked) { ctx.shadowBlur = 15; ctx.shadowColor = s.id === 'med' ? '#f00' : '#0f0'; }
                ctx.fillStyle = s.color; ctx.fillRect(s.x, s.y, s.w, s.h);
                ctx.shadowBlur = 0; ctx.fillStyle = '#fff'; ctx.font = "bold 30px Arial"; ctx.textAlign = "center";
                ctx.fillText(s.icon, s.x + s.w/2, s.y + s.h/2 + 10);
                if (!s.unlocked) { ctx.font = "bold 14px Arial"; ctx.fillStyle = "#FFD700"; ctx.fillText("$"+s.price, s.x + s.w/2, s.y - 10); }
            }

            for (let l of LOOT) {
                ctx.save(); ctx.translate(l.x, l.y); ctx.shadowBlur = 10;
                if (l.type === 0) { ctx.fillStyle = '#ff3333'; ctx.shadowColor = '#f00'; ctx.font = "24px Arial"; ctx.fillText("‚ù§", -12, 8); }
                else if (l.type === 1) { ctx.fillStyle = '#81C784'; ctx.shadowColor = '#0f0'; ctx.fillRect(-24, -12, 48, 24); ctx.fillStyle='#000'; ctx.font="12px monospace"; ctx.fillText("$1", -8, 4); }
                else if (l.type === 2) { ctx.fillStyle = '#4CAF50'; ctx.shadowColor = '#0f0'; ctx.fillRect(-28, -14, 56, 28); ctx.fillStyle='#000'; ctx.font="12px monospace"; ctx.fillText("$5", -8, 4); }
                else if (l.type === 3) { ctx.fillStyle = '#FFD700'; ctx.shadowColor = '#ff0'; ctx.beginPath(); ctx.arc(0,0,15,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#000'; ctx.fillText("$", -5, 5);}
                ctx.restore();
            }

            ctx.shadowBlur = 0;
            for (let p of PARTICLES) { ctx.fillStyle = p.color; ctx.globalAlpha = p.life * 2; ctx.fillRect(p.x, p.y, p.size, p.size); ctx.globalAlpha = 1.0; }

            for (let e of ENEMIES) {
                drawTank(e.x, e.y, e.angle, CONFIG.colors.enemyBody, '#5D4037', false);
                ctx.fillStyle = '#000'; ctx.fillRect(e.x-15, e.y-40, 30, 4);
                ctx.fillStyle = '#f00'; ctx.fillRect(e.x-15, e.y-40, 30 * (e.hp/e.maxHp), 4);
            }

            ctx.lineWidth = 3;
            for (let b of BULLETS) {
                ctx.strokeStyle = (b.owner === 'player') ? '#FFEB3B' : '#FF5252';
                ctx.shadowBlur = 10; ctx.shadowColor = ctx.strokeStyle;
                ctx.beginPath(); ctx.moveTo(b.x - b.vx*0.02, b.y - b.vy*0.02); ctx.lineTo(b.x, b.y); ctx.stroke();
            }
            ctx.shadowBlur = 0;

            drawTank(PLAYER.x, PLAYER.y, PLAYER.bodyAngle, CONFIG.colors.tankBody, CONFIG.colors.tankTurret, true, PLAYER.turretAngle);
            
            const timeSinceAim = Date.now() - INPUT.lastAimTime;
            if (timeSinceAim < 3000) {
                ctx.save(); ctx.translate(PLAYER.x, PLAYER.y); ctx.rotate(PLAYER.turretAngle);
                ctx.strokeStyle = `rgba(255, 255, 255, ${1 - timeSinceAim/3000})`;
                ctx.setLineDash([5, 5]); ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(35, 0); ctx.lineTo(300, 0); ctx.stroke();
                ctx.restore();
            }

            ctx.restore();

            if (STATE.gameStarted && !STATE.isPaused && !STATE.gameOver && STATE.isMobile) {
                if (STATE.staticJoysticks) {
                    drawJoystick({x: canvas.width*0.15, y: canvas.height*0.85}, INPUT.touches.leftId ? INPUT.touches.leftCurr : {x: canvas.width*0.15, y: canvas.height*0.85});
                    if (!STATE.tapToFire) drawJoystick({x: canvas.width*0.85, y: canvas.height*0.85}, INPUT.touches.rightId ? INPUT.touches.rightCurr : {x: canvas.width*0.85, y: canvas.height*0.85});
                } else {
                    if (INPUT.touches.leftId !== null) drawJoystick(INPUT.touches.leftStart, INPUT.touches.leftCurr);
                    if (INPUT.touches.rightId !== null && !STATE.tapToFire) drawJoystick(INPUT.touches.rightStart, INPUT.touches.rightCurr);
                }
            }
        }

        function gameLoop(timestamp) {
            try {
                if (!STATE.lastTime) STATE.lastTime = timestamp;
                const dt = (timestamp - STATE.lastTime) / 1000;
                STATE.lastTime = timestamp;
                update(dt);
                draw();
                if (STATE.showFPS && dt > 0) {
                    FPS.buffer.push(1/dt);
                    if (FPS.buffer.length > 30) FPS.buffer.shift();
                    if (timestamp - FPS.lastUpdate >= 500) {
                        const avg = Math.round(FPS.buffer.reduce((a,b)=>a+b,0)/FPS.buffer.length);
                        const low = Math.round([...FPS.buffer].sort((a,b)=>a-b)[0]);
                        document.getElementById('fps-counter').innerText = `FPS: ${avg} (Low: ${low})`;
                        FPS.lastUpdate = timestamp;
                    }
                }
                requestAnimationFrame(gameLoop);
            } catch (e) {
                console.error("LOOP CRASH", e);
                STATE.gameStarted = false; // Stop loop
                alert("GAME CRASHED: " + e.message);
            }
        }

        // --- 12. UI LOGIC ---
        function updateUIState() {
            const mapAF = ["ANY", "AIMING", "OFF", "NOT AIMING"];
            const descAF = ["Fires on touch.", "Fires when aiming.", "Use fire button.", "Fires when stick touched inside deadzone."];
            const btnAF = document.getElementById('btn-auto-fire');
            const txtAF = document.getElementById('autofire-desc');
            btnAF.innerText = `Auto-Fire: ${mapAF[STATE.autoFireMode]}`;
            txtAF.innerText = descAF[STATE.autoFireMode];
            
            updateToggle('btn-toggle-fps', STATE.showFPS, "Show FPS");
            updateToggle('btn-static-joy', STATE.staticJoysticks, "Static Joysticks");
            updateToggle('btn-tap-fire', STATE.tapToFire, "Tap to Fire");
            updateManualFireButton();
        }
        function updateToggle(id, val, text) {
            const el = document.getElementById(id);
            el.innerText = `${text}: ${val ? 'ON' : 'OFF'}`;
            el.classList.toggle('active', val);
        }

        function setupUI() {
            const bindBtn = (id, cb) => {
                const el = document.getElementById(id);
                if (!el) return;
                const h = (e) => { e.preventDefault(); e.stopPropagation(); cb(el); return false; };
                el.addEventListener('touchend', h, {passive:false}); el.addEventListener('click', h);
            };
            const bindPress = (id, start, end) => {
                const el = document.getElementById(id);
                if (!el) return;
                const s = (e) => { e.preventDefault(); e.stopPropagation(); start(); };
                const f = (e) => { e.preventDefault(); e.stopPropagation(); end(); };
                el.addEventListener('touchstart', s, {passive:false}); el.addEventListener('mousedown', s);
                el.addEventListener('touchend', f, {passive:false}); el.addEventListener('mouseup', f);
            };

            bindBtn('btn-respawn', respawn);
            bindBtn('pause-btn', () => togglePause(true));
            bindBtn('btn-close-pause', () => togglePause(false));
            const overlay = document.getElementById('pause-overlay');
            const closeBg = (e) => { if (e.target === overlay) { e.preventDefault(); togglePause(false); }};
            overlay.addEventListener('touchend', closeBg); overlay.addEventListener('click', closeBg);

            bindBtn('btn-toggle-fps', () => { STATE.showFPS = !STATE.showFPS; document.getElementById('top-left-info').style.display = STATE.showFPS ? 'flex' : 'none'; updateUIState(); saveGame(); });
            
            bindBtn('btn-static-joy', () => { 
                STATE.staticJoysticks = !STATE.staticJoysticks; 
                if (STATE.tapToFire) STATE.tapToFire = false; 
                updateUIState(); saveGame(); 
            });
            
            bindBtn('btn-tap-fire', () => { 
                STATE.tapToFire = !STATE.tapToFire;
                if (STATE.tapToFire) {
                    STATE.savedStatic = STATE.staticJoysticks;
                    STATE.savedAutoFire = STATE.autoFireMode;
                    STATE.staticJoysticks = true; 
                    STATE.autoFireMode = 2; 
                } else {
                    STATE.staticJoysticks = STATE.savedStatic;
                    STATE.autoFireMode = STATE.savedAutoFire;
                }
                updateUIState(); saveGame(); 
            });
            
            bindBtn('btn-auto-fire', () => { 
                STATE.autoFireMode = (STATE.autoFireMode + 1) % 4; 
                if (STATE.tapToFire) STATE.tapToFire = false; 
                updateUIState(); saveGame(); 
            });
            
            bindBtn('btn-toggle-debug', (el) => { STATE.showDebug = !STATE.showDebug; document.getElementById('debug-overlay').style.display = STATE.showDebug ? 'block' : 'none'; document.getElementById('btn-copy-log').style.display = STATE.showDebug ? 'block' : 'none'; el.classList.toggle('active'); });
            
            // Fixed Copy Log
            bindBtn('btn-copy-log', () => {
                const text = DEBUG_LOG.join('\n');
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(text).then(() => alert("Copied to clipboard")).catch(e => fallbackCopy(text));
                } else {
                    fallbackCopy(text);
                }
            });

            bindBtn('btn-start-over', startOver);
            bindBtn('btn-clear-settings', clearSettings);
            
            bindPress('btn-manual-fire', () => STATE.manualFirePressed = true, () => STATE.manualFirePressed = false);
        }

        function fallbackCopy(text) {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                document.execCommand('copy');
                alert("Copied to clipboard (Legacy Mode)");
            } catch (err) {
                alert("Copy failed. Please select text in debug log manually.");
            }
            document.body.removeChild(textArea);
        }

        function togglePause(pause) {
            STATE.isPaused = pause;
            document.getElementById('pause-modal').style.display = pause ? 'block' : 'none';
            document.getElementById('pause-overlay').style.display = pause ? 'block' : 'none';
            if (!pause) STATE.lastTime = performance.now();
        }

        // --- 13. WORLD GEN ---
        // (Moved up for clarity in TS but kept here in strict order for delivery)
        // Note: Already defined above as block 10

        // --- 14. INIT ---
        window.initGame = function() {
            log(`Initializing TTR ${VERSION}`);
            loadGame();
            resize();
            window.addEventListener('resize', resize);
            
            document.getElementById('loading-bar-container').style.display = 'block';
            setTimeout(generateWorld, 50);

            document.getElementById('btn-start').onclick = () => {
                initAudio();
                if (STATE.worldReady) {
                    startGame();
                } else {
                    STATE.startOnLoad = true;
                    document.getElementById('btn-start').style.display = 'none';
                    document.getElementById('loading-bar-container').style.display = 'block';
                    document.getElementById('loading-text').style.visibility = 'visible';
                }
            };

            setupInputs();
            setupUI();
            updateUIState();

            window.addEventListener('blur', () => {
                if (STATE.gameStarted && !STATE.isPaused && !STATE.gameOver) { togglePause(true); resetInputs(); saveGame(); }
            });
        };

        // --- 15. BOOTSTRAP ---
        window.addEventListener('load', function() {
            try {
                if (window.initGame) window.initGame();
                else throw new Error("initGame not found");
            } catch (e) {
                console.error("BOOTSTRAP ERROR", e);
            }
        });

    </script>
</body>
</html>
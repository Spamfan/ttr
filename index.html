<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TTR v8</title>
    <style>
        /* CORE STYLES */
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            touch-action: none;
            font-family: 'Verdana', 'Trebuchet MS', sans-serif;
            color: white;
            user-select: none;
            -webkit-user-select: none;
        }

        canvas {
            display: block;
        }

        /* UI OVERLAY */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .hud-text {
            position: absolute;
            text-shadow: 1px 1px 2px black;
            font-weight: bold;
            pointer-events: auto;
        }

        #version-display {
            top: 10px;
            left: 10px;
            font-size: 12px;
            opacity: 0.7;
        }
        
        #fps-counter {
            top: 50px;
            right: 10px;
            text-align: right;
            font-size: 14px;
        }

        #pause-btn {
            top: 10px;
            right: 10px;
            cursor: pointer;
            font-size: 24px;
            line-height: 24px;
            width: 30px;
            height: 30px;
            text-align: center;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            border: 1px solid #fff;
        }

        /* PAUSE OVERLAY */
        #pause-overlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 10;
            pointer-events: auto; 
        }

        /* PAUSE MODAL */
        #pause-modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #333;
            border: 2px solid #fff;
            padding: 20px;
            text-align: center;
            min-width: 250px;
            box-shadow: 0 0 15px #000;
            z-index: 20;
        }

        .modal-btn {
            display: block;
            width: 100%;
            margin: 10px 0;
            padding: 12px;
            background: #555;
            color: #fff;
            border: 1px solid #aaa;
            cursor: pointer;
            font-family: inherit;
            font-size: 14px;
        }

        .modal-btn.active {
            background: #00dd00;
            color: #000;
            font-weight: bold;
        }
        
        #autofire-desc {
            font-size: 11px;
            color: #aaa;
            margin-bottom: 10px;
            font-style: italic;
        }

        #btn-copy-log {
            display: none;
        }
        
        /* DEBUG OVERLAY */
        #debug-overlay {
            display: none;
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 30%;
            background: rgba(0,0,0,0.5);
            color: #0f0;
            font-family: 'Courier New', monospace;
            overflow-y: scroll;
            font-size: 11px;
            box-sizing: border-box;
            padding: 5px;
            z-index: 5;
            pointer-events: none;
            user-select: none;
        }

        #debug-overlay.interactive {
            pointer-events: auto;
            user-select: text;
            -webkit-user-select: text;
            background: rgba(0,0,0,0.8);
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="version-display" class="hud-text">v8</div>
        <div id="fps-counter" class="hud-text">FPS: 60</div>
        <div id="pause-btn" class="hud-text">&#10074;&#10074;</div>

        <div id="pause-overlay"></div>

        <div id="pause-modal">
            <h3>PAUSED</h3>
            <button id="btn-toggle-fps" class="modal-btn active">Show FPS: ON</button>
            
            <!-- Auto Fire Overhaul -->
            <button id="btn-auto-fire" class="modal-btn active">Auto-Fire: ANY</button>
            <div id="autofire-desc">Fires when right stick is touched.</div>

            <button id="btn-toggle-debug" class="modal-btn">Show Live Debug: OFF</button>
            <button id="btn-copy-log" class="modal-btn">Copy Log</button>
            <button id="btn-close-pause" class="modal-btn" style="background: #800;">RESUME</button>
        </div>
        
        <div id="debug-overlay"></div>
    </div>

    <script>
        /** 
         * TTR ENGINE v8
         * Changes: Tank Rotation Fix, Camera Smoothing, Border Rendering, Grid Visibility, Auto-Fire Modes, iOS Audio Persistence
         */

        const VERSION = "v8";

        // --- CONFIG ---
        const CONFIG = {
            worldSize: 3200,
            playerSpeed: 250, 
            fireRate: 1.0, 
            bulletSpeed: 700, 
            bulletLife: 1.5,
            grassBaseColor: '#2d4c1e',
            gridColor: 'rgba(255, 255, 255, 0.2)', // Increased Opacity (was 0.07)
            gridSize: 64,
            joystickDeadzone: 0.2,
            cameraLerp: 0.1
        };

        // --- STATE ---
        const STATE = {
            lastTime: 0, 
            showFPS: true, 
            showDebug: false,
            autoFireMode: 0, // 0: Any, 1: Aiming
            isMobile: false, 
            isPaused: false, 
            audioInitialized: false
        };

        const CAMERA = { x: 0, y: 0 };
        const FPS = { current: 60, min: 60, max: 60, buffer: [], lastUpdate: 0 };
        const DEBUG_LOG = [];

        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            const entry = `[${timestamp}] ${message}`;
            DEBUG_LOG.push(entry);
            const overlay = document.getElementById('debug-overlay');
            if (overlay) {
                const div = document.createElement('div');
                div.textContent = entry;
                overlay.appendChild(div);
                if (!STATE.isPaused) overlay.scrollTop = overlay.scrollHeight;
            }
        }
        
        // --- AUDIO ---
        let audioCtx = null;
        function initAudio() {
            if (STATE.audioInitialized) return;
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AudioContext();
                STATE.audioInitialized = true;
                log("Audio Context Created.");
            } catch (e) { log("Error: Audio Context failed."); }
        }

        function playShootSound() {
            if (!audioCtx) return;
            // iOS Final Boss Fix: Force Resume if suspended
            if (audioCtx.state !== 'running') {
                audioCtx.resume();
            }

            try {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            } catch (e) {
                // Ignore errors if audio system is busy
            }
        }

        // --- INPUT ---
        const INPUT = {
            keys: {}, mouse: { x: 0, y: 0, down: false }, moveVector: { x: 0, y: 0 },
            aimAngle: 0, isFiring: false,
            touches: {
                leftId: null, leftStart: { x: 0, y: 0 }, leftCurr: { x: 0, y: 0 },
                rightId: null, rightStart: { x: 0, y: 0 }, rightCurr: { x: 0, y: 0 }
            }
        };

        const PLAYER = { 
            x: 1600, y: 1600, radius: 20, 
            color: '#37474F', 
            turretColor: '#546E7A', 
            barrelColor: '#263238', 
            treadColor: '#212121', 
            cooldown: 0, bodyAngle: 0, turretAngle: 0 
        };
        let BULLETS = [];

        // --- RENDERING ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        let backgroundPattern = null;

        function init() {
            log(`Initializing TTR ${VERSION}`);
            createProceduralBackground();
            resize();
            window.addEventListener('resize', resize);
            
            setupInputs();
            setupUI();
            
            // Persistent Audio Unlocker
            const unlockAudio = () => {
                if (!audioCtx) initAudio();
                if (audioCtx && audioCtx.state !== 'running') {
                    audioCtx.resume().then(() => {
                        log("Audio Resumed (Unlock Success).");
                        // Only remove listener if success
                        window.removeEventListener('touchstart', unlockAudio);
                        window.removeEventListener('mousedown', unlockAudio);
                    }).catch(e => {
                        // Keep listener attached to try again next touch
                    });
                }
            };
            window.addEventListener('touchstart', unlockAudio);
            window.addEventListener('mousedown', unlockAudio);

            requestAnimationFrame(gameLoop);
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function createProceduralBackground() {
            const tileSize = 256;
            const tileCanvas = document.createElement('canvas');
            tileCanvas.width = tileSize;
            tileCanvas.height = tileSize;
            const tCtx = tileCanvas.getContext('2d');

            tCtx.fillStyle = CONFIG.grassBaseColor;
            tCtx.fillRect(0, 0, tileSize, tileSize);

            for(let i=0; i<1000; i++) {
                const x = Math.random() * tileSize;
                const y = Math.random() * tileSize;
                const length = 2 + Math.random() * 4;
                const shade = 5 + Math.random() * 15;
                tCtx.strokeStyle = `rgba(0, ${shade}, 0, 0.3)`;
                tCtx.beginPath();
                tCtx.moveTo(x, y);
                tCtx.lineTo(x, y - length);
                tCtx.stroke();
            }

            tCtx.strokeStyle = CONFIG.gridColor;
            tCtx.lineWidth = 1;
            tCtx.strokeRect(0, 0, CONFIG.gridSize, CONFIG.gridSize);

            backgroundPattern = ctx.createPattern(tileCanvas, 'repeat');
        }

        function setupInputs() {
            window.addEventListener('keydown', e => { INPUT.keys[e.key.toLowerCase()] = true; STATE.isMobile = false; });
            window.addEventListener('keyup', e => { INPUT.keys[e.key.toLowerCase()] = false; });
            window.addEventListener('mousemove', e => { INPUT.mouse.x = e.clientX; INPUT.mouse.y = e.clientY; STATE.isMobile = false; });
            window.addEventListener('mousedown', () => { INPUT.mouse.down = true; STATE.isMobile = false; });
            window.addEventListener('mouseup', () => { INPUT.mouse.down = false; });

            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
        }

        function handleTouchStart(e) {
            e.preventDefault();
            STATE.isMobile = true;
            for (let t of e.changedTouches) {
                const isLeft = t.clientX < canvas.width / 2;
                if (isLeft && INPUT.touches.leftId === null) {
                    INPUT.touches.leftId = t.identifier;
                    INPUT.touches.leftStart = { x: t.clientX, y: t.clientY };
                    INPUT.touches.leftCurr = { x: t.clientX, y: t.clientY };
                } else if (!isLeft && INPUT.touches.rightId === null) {
                    INPUT.touches.rightId = t.identifier;
                    INPUT.touches.rightStart = { x: t.clientX, y: t.clientY };
                    INPUT.touches.rightCurr = { x: t.clientX, y: t.clientY };
                }
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            for (let t of e.changedTouches) {
                if (t.identifier === INPUT.touches.leftId) {
                    INPUT.touches.leftCurr = { x: t.clientX, y: t.clientY };
                } else if (t.identifier === INPUT.touches.rightId) {
                    INPUT.touches.rightCurr = { x: t.clientX, y: t.clientY };
                }
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            for (let t of e.changedTouches) {
                if (t.identifier === INPUT.touches.leftId) {
                    INPUT.touches.leftId = null;
                    INPUT.moveVector = { x: 0, y: 0 };
                } else if (t.identifier === INPUT.touches.rightId) {
                    INPUT.touches.rightId = null;
                    INPUT.isFiring = false;
                }
            }
        }

        function update(dt) {
            if (STATE.isPaused) return;

            if (STATE.isMobile) {
                if (INPUT.touches.leftId !== null) {
                    const dx = INPUT.touches.leftCurr.x - INPUT.touches.leftStart.x;
                    const dy = INPUT.touches.leftCurr.y - INPUT.touches.leftStart.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist > 0) {
                        const power = Math.min(dist, 50) / 50;
                        INPUT.moveVector = { x: (dx/dist)*power, y: (dy/dist)*power };
                    }
                }
                if (INPUT.touches.rightId !== null) {
                    const dx = INPUT.touches.rightCurr.x - INPUT.touches.rightStart.x;
                    const dy = INPUT.touches.rightCurr.y - INPUT.touches.rightStart.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    if ((dist / 50) > CONFIG.joystickDeadzone) {
                        INPUT.aimAngle = Math.atan2(dy, dx);
                    }

                    // Auto-Fire Logic
                    if (STATE.autoFireMode === 0) {
                        // Mode 0: Any Touch
                        INPUT.isFiring = true;
                    } else {
                        // Mode 1: Aiming Only (Past deadzone)
                        INPUT.isFiring = (dist / 50) > CONFIG.joystickDeadzone;
                    }
                }
            } else {
                INPUT.moveVector = { x: 0, y: 0 };
                if (INPUT.keys['w'] || INPUT.keys['arrowup']) INPUT.moveVector.y = -1;
                if (INPUT.keys['s'] || INPUT.keys['arrowdown']) INPUT.moveVector.y = 1;
                if (INPUT.keys['a'] || INPUT.keys['arrowleft']) INPUT.moveVector.x = -1;
                if (INPUT.keys['d'] || INPUT.keys['arrowright']) INPUT.moveVector.x = 1;
                if (INPUT.moveVector.x !== 0 || INPUT.moveVector.y !== 0) {
                    const len = Math.sqrt(INPUT.moveVector.x**2 + INPUT.moveVector.y**2);
                    INPUT.moveVector.x /= len; INPUT.moveVector.y /= len;
                }
                INPUT.aimAngle = Math.atan2((INPUT.mouse.y + CAMERA.y) - PLAYER.y, (INPUT.mouse.x + CAMERA.x) - PLAYER.x);
                INPUT.isFiring = INPUT.mouse.down;
            }

            if (INPUT.moveVector.x !== 0 || INPUT.moveVector.y !== 0) {
                PLAYER.bodyAngle = Math.atan2(INPUT.moveVector.y, INPUT.moveVector.x);
            }
            PLAYER.turretAngle = INPUT.aimAngle;

            PLAYER.x += INPUT.moveVector.x * CONFIG.playerSpeed * dt;
            PLAYER.y += INPUT.moveVector.y * CONFIG.playerSpeed * dt;
            
            // World Bound Constraints
            PLAYER.x = Math.max(PLAYER.radius, Math.min(CONFIG.worldSize - PLAYER.radius, PLAYER.x));
            PLAYER.y = Math.max(PLAYER.radius, Math.min(CONFIG.worldSize - PLAYER.radius, PLAYER.y));
            
            // Camera Lerp
            const targetCamX = PLAYER.x - canvas.width / 2;
            const targetCamY = PLAYER.y - canvas.height / 2;
            CAMERA.x += (targetCamX - CAMERA.x) * CONFIG.cameraLerp;
            CAMERA.y += (targetCamY - CAMERA.y) * CONFIG.cameraLerp;

            if (PLAYER.cooldown > 0) PLAYER.cooldown -= dt;
            if (INPUT.isFiring && PLAYER.cooldown <= 0) {
                fireWeapon();
                PLAYER.cooldown = CONFIG.fireRate;
            }
            
            for (let i = BULLETS.length - 1; i >= 0; i--) {
                const b = BULLETS[i];
                b.x += b.vx * dt; b.y += b.vy * dt; b.life -= dt;
                if (b.life <= 0) BULLETS.splice(i, 1);
            }
        }

        function fireWeapon() {
            playShootSound();
            const bX = PLAYER.x + Math.cos(PLAYER.turretAngle) * 35;
            const bY = PLAYER.y + Math.sin(PLAYER.turretAngle) * 35;
            BULLETS.push({
                x: bX, y: bY,
                vx: Math.cos(PLAYER.turretAngle) * CONFIG.bulletSpeed,
                vy: Math.sin(PLAYER.turretAngle) * CONFIG.bulletSpeed,
                life: CONFIG.bulletLife
            });
        }

        function draw() {
            // 1. Clear Screen to Black (The Void)
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            // 2. Move Camera (Integer Rounded for smoothness)
            ctx.translate(Math.round(-CAMERA.x), Math.round(-CAMERA.y));

            // 3. Draw World Background ONLY inside bounds
            ctx.fillStyle = backgroundPattern;
            ctx.fillRect(0, 0, CONFIG.worldSize, CONFIG.worldSize);
            
            // 4. Draw World Border Line
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 5;
            ctx.strokeRect(0, 0, CONFIG.worldSize, CONFIG.worldSize);

            // Bullets
            ctx.strokeStyle = '#ffff00'; ctx.lineWidth = 3; ctx.beginPath();
            for (let b of BULLETS) {
                const tX = b.x - (b.vx / CONFIG.bulletSpeed) * 15;
                const tY = b.y - (b.vy / CONFIG.bulletSpeed) * 15;
                ctx.moveTo(tX, tY); ctx.lineTo(b.x, b.y);
            }
            ctx.stroke();

            // Tank
            ctx.save();
            ctx.translate(PLAYER.x, PLAYER.y);
            
            // Body (Rotated: Width > Height, Treads on Top/Bottom)
            ctx.save();
            ctx.rotate(PLAYER.bodyAngle);
            ctx.fillStyle = PLAYER.color;
            ctx.fillRect(-20, -18, 40, 36); // Main Body (Wide)
            ctx.fillStyle = PLAYER.treadColor;
            ctx.fillRect(-20, -22, 40, 4); // Top Tread
            ctx.fillRect(-20, 18, 40, 4);  // Bottom Tread
            ctx.restore();
            
            // Turret
            ctx.save();
            ctx.rotate(PLAYER.turretAngle);
            ctx.fillStyle = PLAYER.barrelColor;
            ctx.fillRect(0, -4, 35, 8); // Barrel
            ctx.fillStyle = PLAYER.turretColor;
            ctx.beginPath(); ctx.arc(0, 0, 11, 0, Math.PI * 2); ctx.fill(); // Dome
            ctx.strokeStyle = PLAYER.barrelColor; ctx.lineWidth = 1.5; ctx.stroke();
            ctx.restore();
            
            ctx.restore();
            ctx.restore(); // End Camera Translation

            // UI Elements (Not Camera Relative)
            if (!STATE.isPaused) {
                if (INPUT.touches.leftId !== null) drawJoystick(INPUT.touches.leftStart, INPUT.touches.leftCurr);
                if (INPUT.touches.rightId !== null) drawJoystick(INPUT.touches.rightStart, INPUT.touches.rightCurr);
            }
        }

        function drawJoystick(start, curr) {
            ctx.beginPath(); ctx.arc(start.x, start.y, 50, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)'; ctx.lineWidth = 2; ctx.stroke();
            ctx.beginPath(); ctx.arc(curr.x, curr.y, 20, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'; ctx.fill();
        }

        function setupUI() {
            const btnPause = document.getElementById('pause-btn');
            const btnResume = document.getElementById('btn-close-pause');
            const btnCopy = document.getElementById('btn-copy-log');
            const overlay = document.getElementById('pause-overlay');
            const modal = document.getElementById('pause-modal');
            const debug = document.getElementById('debug-overlay');
            const btnAutoFire = document.getElementById('btn-auto-fire');
            const txtAutoFire = document.getElementById('autofire-desc');

            const togglePause = (pause) => {
                STATE.isPaused = pause;
                modal.style.display = pause ? 'block' : 'none';
                overlay.style.display = pause ? 'block' : 'none';
                if (pause) debug.classList.add('interactive');
                else {
                    debug.classList.remove('interactive');
                    STATE.lastTime = performance.now();
                }
            };

            const closeMenu = (e) => { 
                e.preventDefault(); 
                e.stopPropagation(); 
                togglePause(false); 
            };

            // Fix: Add touchend to all UI interactions
            btnPause.onclick = (e) => { e.stopPropagation(); togglePause(true); };
            btnPause.ontouchend = (e) => { e.preventDefault(); e.stopPropagation(); togglePause(true); };
            
            btnResume.onclick = closeMenu;
            btnResume.ontouchend = closeMenu;
            overlay.onclick = closeMenu;
            overlay.ontouchend = closeMenu;

            const btnFps = document.getElementById('btn-toggle-fps');
            const toggleFps = (e) => {
                e.stopPropagation();
                if(e.type === 'touchend') e.preventDefault();
                STATE.showFPS = !STATE.showFPS;
                document.getElementById('fps-counter').style.display = STATE.showFPS ? 'block' : 'none';
                btnFps.innerText = `Show FPS: ${STATE.showFPS ? 'ON' : 'OFF'}`;
                btnFps.classList.toggle('active');
            };
            btnFps.onclick = toggleFps;
            btnFps.ontouchend = toggleFps;

            const toggleAutoFire = (e) => {
                e.stopPropagation();
                if(e.type === 'touchend') e.preventDefault();
                STATE.autoFireMode = (STATE.autoFireMode + 1) % 2;
                if (STATE.autoFireMode === 0) {
                    btnAutoFire.innerText = `Auto-Fire: ANY`;
                    txtAutoFire.innerText = "Fires when right stick is touched.";
                } else {
                    btnAutoFire.innerText = `Auto-Fire: AIMING`;
                    txtAutoFire.innerText = "Fires only when aiming.";
                }
            };
            btnAutoFire.onclick = toggleAutoFire;
            btnAutoFire.ontouchend = toggleAutoFire;

            const btnDebug = document.getElementById('btn-toggle-debug');
            const toggleDebug = (e) => {
                e.stopPropagation();
                if(e.type === 'touchend') e.preventDefault();
                STATE.showDebug = !STATE.showDebug;
                debug.style.display = STATE.showDebug ? 'block' : 'none';
                btnCopy.style.display = STATE.showDebug ? 'block' : 'none';
                btnDebug.innerText = `Show Live Debug: ${STATE.showDebug ? 'ON' : 'OFF'}`;
                btnDebug.classList.toggle('active');
            };
            btnDebug.onclick = toggleDebug;
            btnDebug.ontouchend = toggleDebug;

            const copyLog = (e) => {
                e.stopPropagation();
                if(e.type === 'touchend') e.preventDefault();
                navigator.clipboard.writeText(DEBUG_LOG.join('\n')).then(() => log("Copied to clipboard."));
            };
            btnCopy.onclick = copyLog;
            btnCopy.ontouchend = copyLog;
        }

        function gameLoop(timestamp) {
            if (!STATE.lastTime) STATE.lastTime = timestamp;
            const dt = (timestamp - STATE.lastTime) / 1000;
            STATE.lastTime = timestamp;
            update(dt);
            draw();
            if (STATE.showFPS && dt > 0) {
                const currentFPS = Math.round(1 / dt);
                FPS.buffer.push(currentFPS);
                if (timestamp - FPS.lastUpdate >= 1000) {
                    FPS.current = currentFPS;
                    FPS.min = Math.min(...FPS.buffer); FPS.max = Math.max(...FPS.buffer);
                    FPS.buffer = []; FPS.lastUpdate = timestamp;
                    document.getElementById('fps-counter').innerText = `FPS: ${FPS.current} (${FPS.min}-${FPS.max})`;
                }
            }
            requestAnimationFrame(gameLoop);
        }

        init();
    </script>
</body>
</html>